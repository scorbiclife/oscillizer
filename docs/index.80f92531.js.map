{"mappings":"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","sources":["<anon>","src/index.js","src/MVC/Models/AppState.js","src/MVC/Controllers/PassingController/EventTargetPassingController.js","src/MVC/Controllers/OscStatsController/OscStatsController.js","src/MVC/Controllers/OscStatsController/RLEHelpers.js","src/Engine/RLE/PatternParser.js","src/Engine/RLE/RuleParser.js","src/BaseTypes/Rule/INTRule.js","src/BaseTypes/Rule/TotalisticRule.js","src/MVC/Controllers/OscStatsController/OscHelpers.js","src/BaseTypes/BoundingBox.js","src/BaseTypes/CellMap.js","src/AppConfig.js","src/Engine/Board/SimpleBoard/SimpleTotalisticBoard.js","src/Engine/Board/SimpleBoard/AbcSimpleBoard.js","src/Engine/Board/SimpleBoard/SimpleINTBoard.js","src/BaseTypes/Neighbors/INTNeighbors.js","src/MVC/Views/OscillizerCanvasView/OscillizerCanvasView.js","src/MVC/Views/OscillizerCanvasView/CanvasHelpers.js","src/MVC/Views/OscStatsView/OscStatsView.js"],"sourcesContent":["/**\n * A class that represents a single group of state.\n * @class\n */ class $06c1141a5fa11022$var$AppState {\n    /**\n   * @param {*} value - The initial value of this state\n   * @param {EventTarget} [eventTarget] - The EventTarget to use for firing state changes\n   */ constructor(value, eventTarget){\n        /** @type {EventTarget} */ this.eventTarget = eventTarget || new EventTarget();\n        /** @type {*} */ this.value = value;\n    }\n    /**\n   * Set the value and fire `change` event.\n   * @param {*} newValue - The new value\n   */ setValue(newValue) {\n        this.value = newValue;\n        this.eventTarget.dispatchEvent(new CustomEvent(\"change\", {\n            detail: {\n                source: this\n            }\n        }));\n    }\n}\nvar $06c1141a5fa11022$export$2e2bcd8739ae039 = $06c1141a5fa11022$var$AppState;\n\n\n/**\n * @typedef {import(\"./IController\").IController} IController\n * @typedef {import(\"../../Models/AppState\").default} AppState\n */ /**\n * A controller that just passes the value of `event.target`.\n * `sourceElement` is not needed as we are using `event.target` anyway.\n * @class\n * @implements {IController}\n */ class $005cdf1a540a6299$var$EventTargetPassingController {\n    /**\n   * @param {AppState} targetState\n   */ constructor(targetState){\n        /** @type {AppState} */ this.targetState = targetState;\n        /**\n     * The update callback.\n     * @type {function(Event): void}\n     */ this.update = (event)=>{\n            if (!event.target) return;\n            // @ts-ignore\n            this.targetState.setValue(event.target.value);\n        };\n    }\n}\nvar $005cdf1a540a6299$export$2e2bcd8739ae039 = $005cdf1a540a6299$var$EventTargetPassingController;\n\n\n/**\n * The intermediate state during RLE parsing.\n * @class\n */ class $7eb306c3bbaced74$var$PatternParser {\n    /**\n   * Initialize the parser with the given state.\n   *\n   * @param {Object} initialState - The initial state to override with\n   * @property {boolean|undefined} initialState.isFinished\n   * @property {Array<Cell>|undefined} initialState.cells\n   * @property {Array<number>|undefined} initialState.runCount\n   * @property {Cell|undefined} initialState.currentCell\n   *\n   */ constructor(initialState = {}){\n        /** @type {boolean} */ this.isFinished = initialState.isFinished || false;\n        /** @type {Array<Cell>} */ this.cells = initialState.cells || [];\n        /** @type {number} */ this.runCount = initialState.runCount || 0;\n        /** @type {Cell} */ this.currentCell = initialState.currentCell || [\n            0,\n            0\n        ];\n    }\n    finishParsing() {\n        this.isFinished = true;\n    }\n    addNewlines() {\n        const [, /* x */ y] = this.currentCell;\n        const runCount = this.runCount || 1;\n        this.currentCell = [\n            0,\n            y + runCount\n        ];\n        this.runCount = 0;\n    }\n    /**\n   * Append `digit` to `this.runCount`\n   * @param {number} digit - The digit to append\n   */ updateRunCount(digit) {\n        this.runCount = this.runCount * 10 + digit;\n    }\n    /**\n   * @param {number} cellState\n   */ drawRun(cellState) {\n        const [x, y] = this.currentCell;\n        const runCount = this.runCount || 1;\n        const newCells = new Array(runCount).fill(0).map((v, i)=>[\n                x + i,\n                y\n            ]);\n        // Refactor addNewCells into a dependency if needs variation in behavior\n        const addNewCells = (nc, s)=>{\n            if (s) this.cells = this.cells.concat(nc);\n        };\n        addNewCells(newCells, cellState);\n        this.currentCell = [\n            x + runCount,\n            y\n        ];\n        this.runCount = 0;\n    }\n}\nvar $7eb306c3bbaced74$export$2e2bcd8739ae039 = $7eb306c3bbaced74$var$PatternParser;\n\n\n/**\n * @typedef {import('../Neighbors/INTNeighbors').INTNeighbor} INTNeighbor\n */ /**\n * An Isotropic non-totalistic rule with the given birth and survival conditions.\n */ class $5fea755afec9d72f$var$INTRule {\n    /**\n   * @param {Array<INTNeighbor>} births - The birth conditions\n   * @param {Array<INTNeighbor>} survivals - The survival conditions\n   */ constructor(births, survivals){\n        /** @type {Array<INTNeighbor>} */ this.births = births;\n        /** @type {Array<INTNeighbor>} */ this.survivals = survivals;\n    }\n}\nvar $5fea755afec9d72f$export$2e2bcd8739ae039 = $5fea755afec9d72f$var$INTRule;\n\n\n/**\n * A Totalistic Rule subclass with the given birth and survival conditions.\n */ class $6c574ea9d853ec19$var$TotalisticRule {\n    /**\n   * @param {Array<number>} births\n   * @param {Array<number>} survivals\n   */ constructor(births, survivals){\n        /** @type {Array<number>} */ this.births = births;\n        /** @type {Array<number>} */ this.survivals = survivals;\n    }\n}\nvar $6c574ea9d853ec19$export$2e2bcd8739ae039 = $6c574ea9d853ec19$var$TotalisticRule;\n\n\nconst $7e08f398c2dbe9e4$export$9e91b46a83237852 = (ruleString)=>{\n    /**\n   * @private\n   * @typedef {{\n   *  success: boolean,\n   *  births: Array<number>,\n   *  survivals: Array<number>,\n   *  isBirth: boolean,\n   * }} State\n   */ /**\n   * @param {State} state\n   * @param {string} char\n   * @property {1} char.length\n   * @returns {State} The updated state\n   */ const updateState = (state, char)=>{\n        if (!state.success) return state;\n        const { success: success , births: births , survivals: survivals , isBirth: isBirth  } = state;\n        switch(char){\n            case \"0\":\n            case \"1\":\n            case \"2\":\n            case \"3\":\n            case \"4\":\n            case \"5\":\n            case \"6\":\n            case \"7\":\n            case \"8\":\n                (isBirth ? births : survivals).push(parseInt(char, 10));\n                return {\n                    success: success,\n                    births: births,\n                    survivals: survivals,\n                    isBirth: isBirth\n                };\n            case \"b\":\n            case \"B\":\n                return {\n                    success: success,\n                    births: births,\n                    survivals: survivals,\n                    isBirth: true\n                };\n            case \"s\":\n            case \"S\":\n                return {\n                    success: success,\n                    births: births,\n                    survivals: survivals,\n                    isBirth: false\n                };\n            case \"/\":\n                return {\n                    success: success,\n                    births: births,\n                    survivals: survivals,\n                    isBirth: !isBirth\n                };\n            default:\n                return {\n                    success: false,\n                    births: [],\n                    survivals: [],\n                    isBirth: false\n                };\n        }\n    };\n    const finalState = Array.from(ruleString).reduce(updateState, {\n        success: true,\n        births: [],\n        survivals: [],\n        isBirth: false\n    });\n    if (!finalState.success) return undefined;\n    const births = [\n        ...new Set(finalState.births).keys()\n    ];\n    const survivals = [\n        ...new Set(finalState.survivals).keys()\n    ];\n    return new (0, $6c574ea9d853ec19$export$2e2bcd8739ae039)(births, survivals);\n};\nconst $7e08f398c2dbe9e4$export$6f3ef6963fbc63d1 = (ruleString)=>{\n    /**\n   * @typedef {import('../../BaseTypes/Neighbors/INTNeighbors.js').INTNeighbor} INTNeighbor\n   */ /**\n   * @private\n   * @typedef {{\n   *  isBirth: boolean,\n   *  births: Set<INTNeighbor>,\n   *  survivals: Set<INTNeighbor>,\n   * }} State\n   */ // Dependent function and objects\n    /** @type {function(State): State} */ const copyWithBirth = (state)=>({\n            isBirth: true,\n            births: state.births,\n            survivals: state.survivals\n        });\n    /** @type {function(State): State} */ const copyWithSurvival = (state)=>({\n            isBirth: false,\n            births: state.births,\n            survivals: state.survivals\n        });\n    /** @type {function(State): State} */ const copyWithToggledBirth = (state)=>({\n            isBirth: !state.isBirth,\n            births: state.births,\n            survivals: state.survivals\n        });\n    // Assumes word matches `/[0-8][-cekainyqjrtwz]/`\n    /** @type {Array<Array<INTNeighbor>>} */ const allNeighborsByCount = [\n        [\n            \"0\"\n        ],\n        [\n            \"1c\",\n            \"1e\"\n        ],\n        [\n            \"2c\",\n            \"2e\",\n            \"2a\",\n            \"2k\",\n            \"2i\",\n            \"2n\"\n        ],\n        [\n            \"3c\",\n            \"3e\",\n            \"3a\",\n            \"3k\",\n            \"3i\",\n            \"3n\",\n            \"3j\",\n            \"3q\",\n            \"3r\",\n            \"3y\"\n        ],\n        [\n            \"4c\",\n            \"4e\",\n            \"4a\",\n            \"4k\",\n            \"4i\",\n            \"4n\",\n            \"4j\",\n            \"4q\",\n            \"4r\",\n            \"4y\",\n            \"4t\",\n            \"4w\",\n            \"4z\"\n        ],\n        [\n            \"5c\",\n            \"5e\",\n            \"5a\",\n            \"5k\",\n            \"5i\",\n            \"5n\",\n            \"5j\",\n            \"5q\",\n            \"5r\",\n            \"5y\"\n        ],\n        [\n            \"6c\",\n            \"6e\",\n            \"6a\",\n            \"6k\",\n            \"6i\",\n            \"6n\"\n        ],\n        [\n            \"7c\",\n            \"7e\"\n        ],\n        [\n            \"8\"\n        ]\n    ];\n    /** @type {Array<(Map<string, INTNeighbor>)>} */ const neighborsByCountAndChar = [\n        new Map(),\n        new Map([\n            [\n                \"c\",\n                \"1c\"\n            ],\n            [\n                \"e\",\n                \"1e\"\n            ]\n        ]),\n        new Map([\n            [\n                \"c\",\n                \"2c\"\n            ],\n            [\n                \"e\",\n                \"2e\"\n            ],\n            [\n                \"a\",\n                \"2a\"\n            ],\n            [\n                \"k\",\n                \"2k\"\n            ],\n            [\n                \"i\",\n                \"2i\"\n            ],\n            [\n                \"n\",\n                \"2n\"\n            ]\n        ]),\n        new Map([\n            [\n                \"c\",\n                \"3c\"\n            ],\n            [\n                \"e\",\n                \"3e\"\n            ],\n            [\n                \"a\",\n                \"3a\"\n            ],\n            [\n                \"k\",\n                \"3k\"\n            ],\n            [\n                \"i\",\n                \"3i\"\n            ],\n            [\n                \"n\",\n                \"3n\"\n            ],\n            [\n                \"j\",\n                \"3j\"\n            ],\n            [\n                \"q\",\n                \"3q\"\n            ],\n            [\n                \"r\",\n                \"3r\"\n            ],\n            [\n                \"y\",\n                \"3y\"\n            ]\n        ]),\n        new Map([\n            [\n                \"c\",\n                \"4c\"\n            ],\n            [\n                \"e\",\n                \"4e\"\n            ],\n            [\n                \"a\",\n                \"4a\"\n            ],\n            [\n                \"k\",\n                \"4k\"\n            ],\n            [\n                \"i\",\n                \"4i\"\n            ],\n            [\n                \"n\",\n                \"4n\"\n            ],\n            [\n                \"j\",\n                \"4j\"\n            ],\n            [\n                \"q\",\n                \"4q\"\n            ],\n            [\n                \"r\",\n                \"4r\"\n            ],\n            [\n                \"y\",\n                \"4y\"\n            ],\n            [\n                \"w\",\n                \"4w\"\n            ],\n            [\n                \"t\",\n                \"4t\"\n            ],\n            [\n                \"z\",\n                \"4z\"\n            ]\n        ]),\n        new Map([\n            [\n                \"c\",\n                \"5c\"\n            ],\n            [\n                \"e\",\n                \"5e\"\n            ],\n            [\n                \"a\",\n                \"5a\"\n            ],\n            [\n                \"k\",\n                \"5k\"\n            ],\n            [\n                \"i\",\n                \"5i\"\n            ],\n            [\n                \"n\",\n                \"5n\"\n            ],\n            [\n                \"j\",\n                \"5j\"\n            ],\n            [\n                \"q\",\n                \"5q\"\n            ],\n            [\n                \"r\",\n                \"5r\"\n            ],\n            [\n                \"y\",\n                \"5y\"\n            ]\n        ]),\n        new Map([\n            [\n                \"c\",\n                \"6c\"\n            ],\n            [\n                \"e\",\n                \"6e\"\n            ],\n            [\n                \"a\",\n                \"6a\"\n            ],\n            [\n                \"k\",\n                \"6k\"\n            ],\n            [\n                \"i\",\n                \"6i\"\n            ],\n            [\n                \"n\",\n                \"6n\"\n            ]\n        ]),\n        new Map([\n            [\n                \"c\",\n                \"7c\"\n            ],\n            [\n                \"e\",\n                \"7e\"\n            ]\n        ]),\n        new Map()\n    ];\n    /** @type {function(string): Set<INTNeighbor>} */ const getNeighborsFromWord = (word)=>{\n        const neighborSet = new Set();\n        const count = parseInt(word[0], 10);\n        // The chars before the first `-` are births\n        // The chars after them are survivals\n        const [birthsString, ...survivalsStrings] = word.slice(1).split(\"-\");\n        if (birthsString === \"\") allNeighborsByCount[count].forEach((n)=>neighborSet.add(n));\n        else Array.from(birthsString).forEach((c)=>neighborSet.add(neighborsByCountAndChar[count].get(c)));\n        Array.from(survivalsStrings.join(\"\")).forEach((c)=>neighborSet.delete(neighborsByCountAndChar[count].get(c)));\n        return neighborSet;\n    };\n    // Main logic\n    /** @type {State} */ const initialState = {\n        isBirth: false,\n        births: new Set(),\n        survivals: new Set()\n    };\n    const words = ruleString.match(/[bBsS/]|[0-8][-cekainyqjrtwz]*/g);\n    if (words.reduce((psum, w)=>psum + w.length, 0) !== ruleString.length) return undefined;\n    const finalState = words.reduce((state, word)=>{\n        if (word === \"b\" || word === \"B\") return copyWithBirth(state);\n        if (word === \"s\" || word === \"S\") return copyWithSurvival(state);\n        if (word === \"/\") return copyWithToggledBirth(state);\n        // Neighbors\n        const neighborsSet = getNeighborsFromWord(word);\n        const targetSet = state.isBirth ? state.births : state.survivals;\n        neighborsSet.forEach((n)=>targetSet.add(n));\n        return state;\n    }, initialState);\n    return new (0, $5fea755afec9d72f$export$2e2bcd8739ae039)([\n        ...finalState.births\n    ], [\n        ...finalState.survivals\n    ]);\n};\n\n\n/** @module */ const $c0a50bf5651c6c70$var$mapStateFromChar = new Map([\n    [\n        \".\",\n        0\n    ],\n    [\n        \"A\",\n        1\n    ],\n    [\n        \"B\",\n        0\n    ],\n    [\n        \"C\",\n        1\n    ],\n    [\n        \"D\",\n        0\n    ],\n    [\n        \"E\",\n        1\n    ],\n    [\n        \"F\",\n        0\n    ],\n    [\n        \"b\",\n        0\n    ],\n    [\n        \"o\",\n        1\n    ]\n]);\n/**\n * @private\n * @param {PatternParser} parserState\n * @param {string} c\n * @returns {PatternParser}\n */ const $c0a50bf5651c6c70$var$updateParserState = (parserState, c)=>{\n    // Passthrough if the parser is finished.\n    if (parserState.isFinished) return parserState;\n    if (c === \"!\") {\n        parserState.finishParsing();\n        return parserState;\n    }\n    // Update the run count if it is a digit\n    if (c >= \"0\" && c <= \"9\") {\n        const d = c.charCodeAt(0) - \"0\".charCodeAt(0);\n        parserState.updateRunCount(d);\n        return parserState;\n    }\n    // Jump to next line if it is '$'\n    if (c === \"$\") {\n        parserState.addNewlines();\n        return parserState;\n    }\n    // Draw the run if it is a character\n    const currState = $c0a50bf5651c6c70$var$mapStateFromChar.get(c) || 0;\n    parserState.drawRun(currState);\n    return parserState;\n};\nconst $c0a50bf5651c6c70$export$3b629cd0ff482602 = (rleBodyString)=>{\n    const parseResult = [\n        ...rleBodyString\n    ].reduce($c0a50bf5651c6c70$var$updateParserState, new (0, $7eb306c3bbaced74$export$2e2bcd8739ae039)());\n    parseResult.finishParsing(); // No-op for now but semantically needed\n    return parseResult.cells;\n};\n/* Body extracting related code */ /**\n * @private\n * @param {string} rleString\n * @returns {{body: string, rule: string|null}} The RLE Body and Rule, both as a string\n */ const $c0a50bf5651c6c70$var$extractParts = (rleString)=>{\n    const lines = rleString.split(\"\\n\").map((line)=>line.replace(/\\s/g, \"\")).filter((line)=>line !== \"\"); // We ignore empty lines\n    /** @type {function(string): boolean} */ const isNotComment = (line)=>!line.startsWith(\"#\");\n    const firstNonCommentIndex = lines.findIndex(isNotComment);\n    const headerRegex = /^x=\\d+,y=\\d+,rule=(.*)/;\n    const matchedHeader = headerRegex.exec(lines[firstNonCommentIndex]);\n    const bodyStartIndex = firstNonCommentIndex + (matchedHeader !== null ? 1 : 0);\n    const body = lines.slice(bodyStartIndex).join(\"\");\n    const rule = matchedHeader ? matchedHeader[1] : null;\n    return {\n        body: body,\n        rule: rule\n    };\n};\nconst $c0a50bf5651c6c70$export$98e6a39c04603d36 = (rleString)=>{\n    const { rule: ruleString , body: body  } = $c0a50bf5651c6c70$var$extractParts(rleString);\n    const pattern = $c0a50bf5651c6c70$export$3b629cd0ff482602(body);\n    const rule = (0, $7e08f398c2dbe9e4$export$9e91b46a83237852)(ruleString) || (0, $7e08f398c2dbe9e4$export$6f3ef6963fbc63d1)(ruleString) || undefined;\n    return {\n        pattern: pattern,\n        rule: rule\n    };\n};\n\n\n/**\n * A bounding box consists of min/max of the X/Y coordinates.\n * For an empty pattern the bounding box is `(Inf, Inf, -Inf, -Inf)`\n * because it's an identity in the addition below.\n */ class $4fe0a788fb08d993$var$BoundingBox {\n    /**\n   * @param {number} xmin\n   * @param {number} xmax\n   * @param {number} ymin\n   * @param {number} ymax\n   */ constructor(xmin = Infinity, xmax = -Infinity, ymin = Infinity, ymax = -Infinity){\n        /** @type {number} */ this.xmin = xmin;\n        /** @type {number} */ this.xmax = xmax;\n        /** @type {number} */ this.ymin = ymin;\n        /** @type {number} */ this.ymax = ymax;\n    }\n    /**\n   * Return a new bounding box that is the result of\n   * merging `this` with the `other` bounding box.\n   *\n   * @param {BoundingBox} other - The other box to merge with.\n   * @returns {BoundingBox} - The merged bounding box.\n   */ plus(other) {\n        const xmin = Math.min(this.xmin, other.xmin);\n        const xmax = Math.max(this.xmax, other.xmax);\n        const ymin = Math.min(this.ymin, other.ymin);\n        const ymax = Math.max(this.ymax, other.ymax);\n        return new $4fe0a788fb08d993$var$BoundingBox(xmin, xmax, ymin, ymax);\n    }\n    /**\n   * Given an array of bounding boxes, merge all of them and return the merged box.\n   *\n   * @param  {Array<BoundingBox>} boxes - The boxes to merge.\n   * @returns {BoundingBox} - The merged bounding box.\n   */ static sum(boxes) {\n        return boxes.reduce((psum, box)=>psum.plus(box), new $4fe0a788fb08d993$var$BoundingBox());\n    }\n}\nvar $4fe0a788fb08d993$export$2e2bcd8739ae039 = $4fe0a788fb08d993$var$BoundingBox;\n\n\n/**\n * @private\n * @type {function(number, number): string}\n */ const $b455d5ebeb71c1de$var$cellToString = (x, y)=>`${x} ${y}`;\n/**\n * @private\n * @type {function(string): Cell}\n */ const $b455d5ebeb71c1de$var$stringToCell = (s)=>s.split(\" \").map((e)=>parseInt(e, 10));\n/**\n * Map data structure that accepts Cells: [x: number, y: number] as keys.\n *\n * We need to implement this because\n * JS does not support non-primitive value types as keys (as of ES6)\n */ class $b455d5ebeb71c1de$var$CellMap {\n    /**\n   * @param {Array<CellEntry>} [entries=[]]\n   */ constructor(entries = []){\n        /** @type {Map<string, *>} */ this.map = new Map();\n        entries.forEach(([x, y], value)=>this.set([\n                x,\n                y\n            ], value));\n    }\n    /**\n   * Generate and return a `CellMap` from list of keys.\n   *\n   * @param {Array} keys - Array of cells, each of type `[number, number]`.\n   * @returns - The CellMap having the given keys with values mapped to null\n   */ static fromKeys(keys) {\n        const map = new $b455d5ebeb71c1de$var$CellMap();\n        keys.forEach(([x, y])=>map.set([\n                x,\n                y\n            ], null));\n        return map;\n    }\n    /**\n   * Generate and return a `CellMap` with the given entries.\n   *\n   * This is the same as the constructor, but is presented here\n   * as an analogue to `fromKeys`.\n   *\n   * @param {Array} entries - Array of [cell, value] pairs\n   * @returns The resulting CellMap having the given entries\n   */ static fromEntries(entries) {\n        return new $b455d5ebeb71c1de$var$CellMap(entries);\n    }\n    /**\n   * Return whether a cell is in the map to Map.\n   *\n   * @param {*} key - cell to search for, has type `[number, number]`.\n   * @returns A boolean indicating whether the cell is in the set\n   */ has(key) {\n        const [x, y] = key;\n        return this.map.has($b455d5ebeb71c1de$var$cellToString(x, y));\n    }\n    /**\n   * Get the value for the given key.\n   * If not found, return `defaultValue` as a fallback.\n   *\n   * @param {Cell} key - The key to get values for.\n   * @param {*} defaultValue - The value to return when the key is not found.\n   * @returns - The found value or `defaultValue`\n   */ get(key, defaultValue) {\n        const [x, y] = key;\n        const value = this.map.get($b455d5ebeb71c1de$var$cellToString(x, y));\n        return value !== undefined ? value : defaultValue;\n    }\n    /**\n   * Set the value for the given key.\n   *\n   * @param {Cell} key - The key to set values for.\n   * @param {*} value - The value to set.\n   */ set(key, value) {\n        const [x, y] = key;\n        this.map.set($b455d5ebeb71c1de$var$cellToString(x, y), value);\n    }\n    /**\n   * Return the number of keys of the map, analogous to `Map`.\n   */ get size() {\n        return this.map.size;\n    }\n    /**\n   * Return the keys of this map as in `Map`.\n   * @returns A list of keys for the map.\n   */ keys() {\n        return [\n            ...this.map.keys()\n        ].map($b455d5ebeb71c1de$var$stringToCell);\n    }\n    /**\n   * Return the entries (i.e. key, value pairs) of this map, as in `Map`.\n   * @returns A list of entries for the map.\n   */ entries() {\n        return [\n            ...this.map.entries()\n        ].map(([s, v])=>[\n                $b455d5ebeb71c1de$var$stringToCell(s),\n                v\n            ]);\n    }\n}\nvar $b455d5ebeb71c1de$export$2e2bcd8739ae039 = $b455d5ebeb71c1de$var$CellMap;\n\n\nconst $33c87e009b185634$export$decf60f46c2b52d8 = (board, maxGens = 1000)=>{\n    /**\n   * @param {Array} array\n   * @param {Set} set\n   * @returns {boolean}\n   */ const haveSameMembers = (array, set)=>array.length === set.size && array.every((cell)=>set.has(cell));\n    const appendNextBoard = ({ result: result , lastBoards: lastBoards , initialCellsSet: initialCellsSet  })=>{\n        if (result.length !== 0) return {\n            result: result,\n            lastBoards: lastBoards,\n            initialCellsSet: initialCellsSet\n        };\n        /** @type {IBoard} */ const lastBoard = lastBoards[lastBoards.length - 1];\n        /** @type {IBoard} */ const currBoard = lastBoard.after();\n        if (haveSameMembers(currBoard.getCells(), initialCellsSet)) return {\n            result: lastBoards,\n            lastBoards: [],\n            initialCellsSet: initialCellsSet\n        };\n        return {\n            result: [],\n            lastBoards: lastBoards.concat(currBoard),\n            initialCellsSet: initialCellsSet\n        };\n    };\n    const repeatForMaxGens = new Array(maxGens).fill();\n    const initialData = {\n        result: [],\n        lastBoards: [\n            board\n        ],\n        initialCellsSet: (0, $b455d5ebeb71c1de$export$2e2bcd8739ae039).fromKeys(board.getCells())\n    };\n    const phases = repeatForMaxGens.reduce(appendNextBoard, initialData).result;\n    return phases; // Return empty array on failure\n};\nconst $33c87e009b185634$export$2f3e39639c1a2e58 = (oscPhaseBoards)=>{\n    // Get the list of oscillator phases.\n    // Return a list of `{ cell, aliveGens }` where `aliveGens` is the gens `cell` was alive.\n    const getAliveGensByCell = (phases)=>{\n        const phasesSet = phases.map((0, $b455d5ebeb71c1de$export$2e2bcd8739ae039).fromKeys);\n        const allCells = (0, $b455d5ebeb71c1de$export$2e2bcd8739ae039).fromKeys([].concat(...phases)).keys();\n        const gens = phases.map((_, gen)=>gen);\n        return allCells.map((cell)=>({\n                cell: cell,\n                aliveGens: gens.filter((gen)=>phasesSet[gen].has(cell))\n            }));\n    };\n    // Get the list of gens a cell was alive.\n    // Return the subperiod.\n    const getSubperiodOfOneCell = (aliveGens, period)=>{\n        const aliveGensSet = new Set(aliveGens);\n        const subperiods = new Array(period).fill().map((_, i)=>i + 1).filter((n)=>period % n === 0);\n        const isSubperiodValid = (n)=>aliveGens.map((g)=>(g + n) % period).every((g)=>aliveGensSet.has(g));\n        const validSubperiods = subperiods.filter(isSubperiodValid);\n        return Math.min(...validSubperiods);\n    };\n    const period = oscPhaseBoards.length;\n    const result = getAliveGensByCell(oscPhaseBoards.map((b)=>b.getCells())).map(({ cell: cell , aliveGens: aliveGens  })=>({\n            cell: cell,\n            subperiod: getSubperiodOfOneCell(aliveGens, period)\n        }));\n    return result;\n};\nconst $33c87e009b185634$export$a50fceef87b2948 = (board)=>{\n    // Basic functions\n    /** @type {function(Array<number>): number} */ const getAverage = (l)=>l.reduce((a, b)=>a + b, 0) / l.length;\n    /** @type {function(number): string} */ const formatFloat = (f)=>f.toFixed(2);\n    /** @type {function(number): string} */ const formatPercentage = (f)=>`${(100 * f).toFixed(2)}%`;\n    // Status functions\n    /** @typedef {Array<{cell: Cell, subperiod: number}>} Subperiods */ /** @type {function(Subperiods): number} */ const getRotorCount = (subperiods)=>subperiods.filter(({ subperiod: subperiod  })=>subperiod !== 1).length;\n    /** @type {function(Subperiods, number): number} */ const getStrictRotorCount = (subperiods, period)=>subperiods.filter(({ subperiod: subperiod  })=>subperiod === period).length;\n    /** @type {function(Subperiods): number} */ const getVolatility = (subperiods)=>getRotorCount(subperiods) / subperiods.length;\n    /** @type {function(Subperiods, number): number} */ const getStrictVolatility = (subperiods, period)=>getStrictRotorCount(subperiods, period) / subperiods.length;\n    // Main code\n    const phaseBoards = $33c87e009b185634$export$decf60f46c2b52d8(board);\n    const period = phaseBoards.length;\n    if (period === 0) return {\n        success: false,\n        message: \"Failed to detect period of pattern\"\n    };\n    const populations = phaseBoards.map((b)=>b.getPop());\n    const subperiods = $33c87e009b185634$export$2f3e39639c1a2e58(phaseBoards);\n    const result = {\n        success: true,\n        pattern: board.getCells(),\n        period: period,\n        phases: phaseBoards.map((p)=>p.getCells()),\n        subperiods: subperiods,\n        minPop: Math.min(...populations),\n        maxPop: Math.max(...populations),\n        avgPop: formatFloat(getAverage(populations)),\n        numCells: subperiods.length,\n        numRotorCells: getRotorCount(subperiods),\n        numStatorCells: subperiods.length - getRotorCount(subperiods),\n        numStrictRotorCells: getStrictRotorCount(subperiods, period),\n        volatility: formatPercentage(getVolatility(subperiods)),\n        strictVolatility: formatPercentage(getStrictVolatility(subperiods, period)),\n        boundingBox: (0, $4fe0a788fb08d993$export$2e2bcd8739ae039).sum(phaseBoards.map((p)=>p.getBox()))\n    };\n    return result;\n};\n\n\n\n/**\n * @typedef {import('../../../BaseTypes/Rule/Rule').Rule} Rule\n * @typedef {import('../IBoard').IBoard} IBoard\n * @typedef {import('./SimpleTotalisticBoard').default} SimpleTotalisticBoard\n */ /**\n * @typedef {function(Array<Cell>): Array<Cell>} TransitionFunction\n */ /**\n * This simple interface consists of a `pattern` and a `transitionFunction`.\n * It applies the `transitionFunction` on the `pattern` to get the next generation.\n * Other auxillary information is extracted from the `pattern`.\n *\n * IMPORTANT:\n *\n *  This class is made to reduce boilerplate.\n *  You don't need to inherit from this class;\n *  You just have to implement `I{Totalistic,INT}Board` interfaces.\n *\n *  If you are using this class, make sure to initialize `this.transitionFunction` properly,\n *  with the rule given as the parameter, with the proper type of {@link TransitionFunction}.\n *  For example classes, see {@link SimpleTotalisticBoard}.\n *\n * @implements {IBoard}\n *\n */ class $7c60ee827e62c391$var$AbcSimpleBoard {\n    /**\n   * @param {TwoStatePattern} pattern\n   * @param {Rule} rule\n   * @param {number} gen\n   */ constructor(pattern, rule, gen){\n        /** @type {TwoStatePattern} */ this.pattern = pattern;\n        /** @type {Rule} */ this.rule = rule;\n        /** @type {number} */ this.gen = gen;\n        /**\n     * This should be overriden by concrete implementations!\n     * @type {any}\n     */ this.transitionFunction = undefined;\n    }\n    getCells() {\n        return this.pattern;\n    }\n    getCellsAndStates() {\n        return this.pattern.map((cell)=>[\n                cell,\n                1\n            ]);\n    }\n    getBox() {\n        return (0, $4fe0a788fb08d993$export$2e2bcd8739ae039).sum(this.pattern.map(([x, y])=>new (0, $4fe0a788fb08d993$export$2e2bcd8739ae039)(x, x, y, y)));\n    }\n    getPop() {\n        return this.pattern.length;\n    }\n    /**\n   * Return a new board with the pattern iterated by the given amount.\n   *\n   * @param {number} [gens=1] - Number of generations to iterate\n   * @returns {AbcSimpleBoard} - The new board\n   */ after(gens = 1) {\n        const repeatForGens = new Array(gens).fill();\n        /** @type {TransitionFunction} */ const transFunc = this.transitionFunction;\n        /** @type {Array<Cell>} */ const iteratedPattern = repeatForGens.reduce(transFunc, this.pattern);\n        /** @type {any} */ const ThisClass = this.constructor;\n        return new ThisClass(iteratedPattern, this.rule, this.gen + gens);\n    }\n}\nvar $7c60ee827e62c391$export$2e2bcd8739ae039 = $7c60ee827e62c391$var$AbcSimpleBoard;\n\n\n\nconst $cdbcd7a52f96e34a$var$moore = [\n    [\n        -1,\n        -1\n    ],\n    [\n        -1,\n        0\n    ],\n    [\n        -1,\n        1\n    ],\n    [\n        0,\n        -1\n    ],\n    [\n        0,\n        0\n    ],\n    [\n        0,\n        1\n    ],\n    [\n        1,\n        -1\n    ],\n    [\n        1,\n        0\n    ],\n    [\n        1,\n        1\n    ]\n];\n/**\n * @private\n * @param {Array<Cell>} cellsArray\n * @param {Array<Cell>} neighbors\n * @returns {CellMap}\n */ const $cdbcd7a52f96e34a$var$getNeighborCounts = (cellsArray, neighbors)=>{\n    const neighborCountsMap = new (0, $b455d5ebeb71c1de$export$2e2bcd8739ae039)();\n    cellsArray.forEach(([x, y])=>{\n        neighbors.forEach(([dx, dy])=>{\n            const targetCell = [\n                x + dx,\n                y + dy\n            ];\n            const count = neighborCountsMap.get(targetCell) || 0;\n            neighborCountsMap.set(targetCell, count + 1);\n        });\n    });\n    return neighborCountsMap;\n};\n/**\n * @typedef {import('./AbcSimpleBoard').TransitionFunction} TransitionFunction\n */ /**\n * @private\n * @param {TotalisticRule} totalisticRule\n * @returns {TransitionFunction}\n */ const $cdbcd7a52f96e34a$var$makeTransFromTotalisticRule = (totalisticRule)=>(cellsArray)=>{\n        const { births: births , survivals: survivals  } = totalisticRule;\n        const neighborCounts = $cdbcd7a52f96e34a$var$getNeighborCounts(cellsArray, $cdbcd7a52f96e34a$var$moore);\n        const cellsSet = (0, $b455d5ebeb71c1de$export$2e2bcd8739ae039).fromKeys(cellsArray);\n        const ruleCondition = ([cell, count])=>cellsSet.has(cell) ? survivals.includes(count - 1) // -1: `count` includes `cell`, while B/S notation doesn't\n             : births.includes(count);\n        return [\n            ...neighborCounts.entries()\n        ].filter(ruleCondition).map(([cell /* count */ ])=>cell);\n    };\n/**\n * A sample implementation for totalistic rules.\n * @class\n * @implements {ITotalisticBoard}\n */ class $cdbcd7a52f96e34a$var$SimpleTotalisticBoard extends (0, $7c60ee827e62c391$export$2e2bcd8739ae039) {\n    /**\n   * Initialize the board with the given pattern and rule.\n   *\n   * @constructor\n   * @param {TwoStatePattern} pattern - The initial pattern.\n   * @param {TotalisticRule} rule - The rule to operate on the pattern with.\n   * @param {number} [gen=0] - The initial generation.\n   */ constructor(pattern, rule, gen = 0){\n        super(pattern, rule, gen);\n        this.transitionFunction = $cdbcd7a52f96e34a$var$makeTransFromTotalisticRule(rule);\n    }\n}\nvar $cdbcd7a52f96e34a$export$2e2bcd8739ae039 = $cdbcd7a52f96e34a$var$SimpleTotalisticBoard;\n\n\n\n\n\n\n/** @module */ /**\n * An enum for specifying neighbors for INT rules.\n */ const $a97e00b3534022fc$export$160e8bdd97bfce3a = {\n    // eslint-disable-next-line quote-props\n    0: \"0\",\n    \"1c\": \"1c\",\n    \"1e\": \"1e\",\n    \"2c\": \"2c\",\n    \"2e\": \"2e\",\n    \"2a\": \"2a\",\n    \"2k\": \"2k\",\n    \"2i\": \"2i\",\n    \"2n\": \"2n\",\n    \"3c\": \"3c\",\n    \"3e\": \"3e\",\n    \"3a\": \"3a\",\n    \"3k\": \"3k\",\n    \"3i\": \"3i\",\n    \"3n\": \"3n\",\n    \"3j\": \"3j\",\n    \"3q\": \"3q\",\n    \"3r\": \"3r\",\n    \"3y\": \"3y\",\n    \"4c\": \"4c\",\n    \"4e\": \"4e\",\n    \"4a\": \"4a\",\n    \"4k\": \"4k\",\n    \"4i\": \"4i\",\n    \"4n\": \"4n\",\n    \"4j\": \"4j\",\n    \"4q\": \"4q\",\n    \"4r\": \"4r\",\n    \"4y\": \"4y\",\n    \"4t\": \"4t\",\n    \"4w\": \"4w\",\n    \"4z\": \"4z\",\n    \"5c\": \"5c\",\n    \"5e\": \"5e\",\n    \"5a\": \"5a\",\n    \"5k\": \"5k\",\n    \"5i\": \"5i\",\n    \"5n\": \"5n\",\n    \"5j\": \"5j\",\n    \"5q\": \"5q\",\n    \"5r\": \"5r\",\n    \"5y\": \"5y\",\n    \"6c\": \"6c\",\n    \"6e\": \"6e\",\n    \"6a\": \"6a\",\n    \"6k\": \"6k\",\n    \"6i\": \"6i\",\n    \"6n\": \"6n\",\n    \"7c\": \"7c\",\n    \"7e\": \"7e\",\n    // eslint-disable-next-line quote-props\n    8: \"8\"\n};\nconst $a97e00b3534022fc$export$10cb2c208909f427 = `\n    0 1c 1e 2a 1c 2c 2a 3i 1e 2a 2e 3a 2k 3n 3j 4a\n    0 1c 1e 2a 1c 2c 2a 3i 1e 2a 2e 3a 2k 3n 3j 4a\n    1e 2k 2e 3j 2a 3n 3a 4a 2i 3r 3e 4r 3r 4i 4r 5i\n    1e 2k 2e 3j 2a 3n 3a 4a 2i 3r 3e 4r 3r 4i 4r 5i\n    1c 2c 2k 3n 2n 3c 3q 4n 2a 3i 3j 4a 3q 4n 4w 5a\n    1c 2c 2k 3n 2n 3c 3q 4n 2a 3i 3j 4a 3q 4n 4w 5a\n    2k 3y 3k 4k 3q 4y 4q 5j 3r 4t 4j 5n 4z 5r 5q 6a\n    2k 3y 3k 4k 3q 4y 4q 5j 3r 4t 4j 5n 4z 5r 5q 6a\n    1e 2k 2i 3r 2k 3y 3r 4t 2e 3j 3e 4r 3k 4k 4j 5n\n    1e 2k 2i 3r 2k 3y 3r 4t 2e 3j 3e 4r 3k 4k 4j 5n\n    2e 3k 3e 4j 3j 4k 4r 5n 3e 4j 4e 5c 4j 5y 5c 6c\n    2e 3k 3e 4j 3j 4k 4r 5n 3e 4j 4e 5c 4j 5y 5c 6c\n    2a 3n 3r 4i 3q 4y 4z 5r 3a 4a 4r 5i 4q 5j 5q 6a\n    2a 3n 3r 4i 3q 4y 4z 5r 3a 4a 4r 5i 4q 5j 5q 6a\n    3j 4k 4j 5y 4w 5k 5q 6k 4r 5n 5c 6c 5q 6k 6n 7c\n    3j 4k 4j 5y 4w 5k 5q 6k 4r 5n 5c 6c 5q 6k 6n 7c\n    1c 2n 2k 3q 2c 3c 3n 4n 2k 3q 3k 4q 3y 4y 4k 5j\n    1c 2n 2k 3q 2c 3c 3n 4n 2k 3q 3k 4q 3y 4y 4k 5j\n    2a 3q 3j 4w 3i 4n 4a 5a 3r 4z 4j 5q 4t 5r 5n 6a\n    2a 3q 3j 4w 3i 4n 4a 5a 3r 4z 4j 5q 4t 5r 5n 6a\n    2c 3c 3y 4y 3c 4c 4y 5e 3n 4n 4k 5j 4y 5e 5k 6e\n    2c 3c 3y 4y 3c 4c 4y 5e 3n 4n 4k 5j 4y 5e 5k 6e\n    3n 4y 4k 5k 4n 5e 5j 6e 4i 5r 5y 6k 5r 6i 6k 7e\n    3n 4y 4k 5k 4n 5e 5j 6e 4i 5r 5y 6k 5r 6i 6k 7e\n    2a 3q 3r 4z 3n 4y 4i 5r 3j 4w 4j 5q 4k 5k 5y 6k\n    2a 3q 3r 4z 3n 4y 4i 5r 3j 4w 4j 5q 4k 5k 5y 6k\n    3a 4q 4r 5q 4a 5j 5i 6a 4r 5q 5c 6n 5n 6k 6c 7c\n    3a 4q 4r 5q 4a 5j 5i 6a 4r 5q 5c 6n 5n 6k 6c 7c\n    3i 4n 4t 5r 4n 5e 5r 6i 4a 5a 5n 6a 5j 6e 6k 7e\n    3i 4n 4t 5r 4n 5e 5r 6i 4a 5a 5n 6a 5j 6e 6k 7e\n    4a 5j 5n 6k 5a 6e 6a 7e 5i 6a 6c 7c 6a 7e 7c 8\n    4a 5j 5n 6k 5a 6e 6a 7e 5i 6a 6c 7c 6a 7e 7c 8\n  `.trim().split(/\\s+/);\n\n\n/**\n * @typedef {import('./AbcSimpleBoard').TransitionFunction} TransitionFunction\n */ const $e7bed22a29553bb6$var$weightsByRelPos = new Map([\n    [\n        [\n            -1,\n            -1\n        ],\n        1\n    ],\n    [\n        [\n            -1,\n            0\n        ],\n        2\n    ],\n    [\n        [\n            -1,\n            1\n        ],\n        4\n    ],\n    [\n        [\n            0,\n            -1\n        ],\n        8\n    ],\n    [\n        [\n            0,\n            0\n        ],\n        16\n    ],\n    [\n        [\n            0,\n            1\n        ],\n        32\n    ],\n    [\n        [\n            1,\n            -1\n        ],\n        64\n    ],\n    [\n        [\n            1,\n            0\n        ],\n        128\n    ],\n    [\n        [\n            1,\n            1\n        ],\n        256\n    ]\n]);\n/**\n * @private\n * @param {Array<Cell>} cellsArray\n * @returns {CellMap}\n */ const $e7bed22a29553bb6$var$getNeighborTransitionIndexes = (cellsArray)=>{\n    const neighborTransitions = new (0, $b455d5ebeb71c1de$export$2e2bcd8739ae039)();\n    cellsArray.forEach(([x, y])=>{\n        $e7bed22a29553bb6$var$weightsByRelPos.forEach((w, [dx, dy])=>{\n            const targetCell = [\n                x - dx,\n                y - dy\n            ]; // So that [x, y] is at rel. pos. [dx, dy]\n            const currentWeight = neighborTransitions.get(targetCell) || 0;\n            neighborTransitions.set(targetCell, currentWeight + w);\n        });\n    });\n    return neighborTransitions;\n};\n/**\n * @private\n * @param {INTRule} rule\n * @returns {TransitionFunction}\n */ const $e7bed22a29553bb6$var$makeTransitionFunction = (rule)=>(cellsArray)=>{\n        const transitionIndexesByCell = $e7bed22a29553bb6$var$getNeighborTransitionIndexes(cellsArray);\n        const nextCells = [\n            ...transitionIndexesByCell.entries()\n        ].filter(([, tIndex])=>{\n            // The 0x10 bit is the center cell.\n            // eslint-disable-next-line no-bitwise\n            const cellIsAlive = (tIndex & 0x10) !== 0;\n            const validTransitions = cellIsAlive ? rule.survivals : rule.births;\n            return validTransitions.includes((0, $a97e00b3534022fc$export$10cb2c208909f427)[tIndex]);\n        }).map(([cell])=>cell);\n        return nextCells;\n    };\nclass $e7bed22a29553bb6$var$SimpleINTBoard extends (0, $7c60ee827e62c391$export$2e2bcd8739ae039) {\n    /**\n   * @param {TwoStatePattern} pattern\n   * @param {INTRule} rule\n   * @param {number} gen\n   */ constructor(pattern, rule, gen = 0){\n        super(pattern, rule, gen);\n        /** @type {TransitionFunction} */ this.transitionFunction = $e7bed22a29553bb6$var$makeTransitionFunction(rule);\n    }\n}\nvar $e7bed22a29553bb6$export$2e2bcd8739ae039 = $e7bed22a29553bb6$var$SimpleINTBoard;\n\n\nconst $3f27e148c19edda2$var$life = new (0, $6c574ea9d853ec19$export$2e2bcd8739ae039)([\n    3\n], [\n    2,\n    3\n]);\nconst $3f27e148c19edda2$export$c68329e72259b1d3 = (pattern, rule = $3f27e148c19edda2$var$life)=>{\n    if (rule.constructor === (0, $6c574ea9d853ec19$export$2e2bcd8739ae039)) return new (0, $cdbcd7a52f96e34a$export$2e2bcd8739ae039)(pattern, rule);\n    if (rule.constructor === (0, $5fea755afec9d72f$export$2e2bcd8739ae039)) return new (0, $e7bed22a29553bb6$export$2e2bcd8739ae039)(pattern, rule);\n    throw new Error(\"Invalid Rule!\");\n};\nconst $3f27e148c19edda2$export$127ea844e1508b8d = (rule = $3f27e148c19edda2$var$life)=>$3f27e148c19edda2$export$c68329e72259b1d3([], rule);\n\n\n/**\n * @typedef {import('../PassingController/IController.js').IController}  IController\n * @typedef {import('../../Models/AppState').default} AppState\n */ /**\n * A controller that updates the target with osc stats, with the given RLE.\n * @class\n * @implements {IController}\n */ class $ce1ca3b02054b188$var$OscStatsController {\n    /**\n   * @param {AppState} targetState\n   * @param {HTMLInputElement} sourceElement\n   */ constructor(targetState, sourceElement){\n        /** @type {AppState} */ this.targetState = targetState;\n        /** @type {HTMLInputElement} */ this.sourceElement = sourceElement;\n        /**\n     * The update callback.\n     * @type {function(Event): void}\n     */ this.update = (event)=>{\n            if (!event.target) {\n                this.targetState.setValue({\n                    success: false,\n                    message: \"No event.target\"\n                });\n                return;\n            }\n            const rleString = this.sourceElement.value;\n            const { pattern: pattern , rule: rule  } = (0, $c0a50bf5651c6c70$export$98e6a39c04603d36)(rleString);\n            if (!rule) {\n                this.targetState.setValue({\n                    success: false,\n                    message: \"Unable to parse rule\"\n                });\n                return;\n            }\n            const initialBoard = $3f27e148c19edda2$export$c68329e72259b1d3(pattern, rule);\n            this.targetState.setValue((0, $33c87e009b185634$export$a50fceef87b2948)(initialBoard));\n        };\n    }\n}\nvar $ce1ca3b02054b188$export$2e2bcd8739ae039 = $ce1ca3b02054b188$var$OscStatsController;\n\n\n/**\n * @typedef {import('../../../BaseTypes/BoundingBox').default} BoundingBox\n */ const $25ddeeb3e8fa7df7$var$colorscheme = {\n    background: \"#eeeeee\",\n    stator: \"#000000\",\n    strictRotor: \"#999999\",\n    liveCell: \"#000000\"\n};\n// Cell size follows `box-sizing: border-box`\n// In other words, borders on all four sides are counted as cellSize.\nconst $25ddeeb3e8fa7df7$var$cellSizes = {\n    cell: 10,\n    border: 1,\n    liveCell: 4,\n    liveBorder: 2\n};\n/** @type {function(number, number): string} */ const $25ddeeb3e8fa7df7$var$makeGradientColor = (numColors, i)=>{\n    const hue = Math.floor(360 * (i / numColors));\n    return `hsl(${hue}, 100%, 70%)`;\n};\nconst $25ddeeb3e8fa7df7$export$dafb4586fe1f0b47 = (period, subperiods)=>{\n    // Remove special subperiods:\n    //  subperiod 1 (stator)\n    //  subperiod `period` (full-period rotor)\n    const subperiodsSet = new Set(subperiods);\n    subperiodsSet.delete(1);\n    subperiodsSet.delete(period);\n    const nonSpecialSubperiods = [\n        ...subperiodsSet.values()\n    ].sort((a, b)=>a - b);\n    /** @type {Array<[number, string]>} */ const nonSpecialSubperiodsAndColors = nonSpecialSubperiods.map((sp, i)=>[\n            sp,\n            $25ddeeb3e8fa7df7$var$makeGradientColor(nonSpecialSubperiods.length, i)\n        ]);\n    return new Map([\n        ...nonSpecialSubperiodsAndColors,\n        [\n            1,\n            $25ddeeb3e8fa7df7$var$colorscheme.stator\n        ],\n        [\n            period,\n            $25ddeeb3e8fa7df7$var$colorscheme.strictRotor\n        ]\n    ]);\n};\nconst $25ddeeb3e8fa7df7$export$20d2db9c68afeac = (canvas, context, boundingBox)=>{\n    // We have to manipulate the canvas, so first beg pardon to ESLint\n    /* eslint-disable no-param-reassign */ const { cell: cellSize , border: borderWidth  } = $25ddeeb3e8fa7df7$var$cellSizes;\n    // First fill rect with empty cell backgrounds.\n    const patternWidth = boundingBox.xmax - boundingBox.xmin + 1;\n    const patternHeight = boundingBox.ymax - boundingBox.ymin + 1;\n    // Add one cell for padding on each side.\n    canvas.width = cellSize * (patternWidth + 2);\n    canvas.height = cellSize * (patternHeight + 2);\n    // Draw background\n    context.fillStyle = $25ddeeb3e8fa7df7$var$colorscheme.background;\n    context.fillRect(0, 0, canvas.width, canvas.height);\n    // Draw cell borders\n    context.fillStyle = \"white\";\n    new Array(patternHeight + 2).fill().forEach((_, i)=>{\n        context.fillRect(0, cellSize * i, canvas.width, borderWidth);\n        context.fillRect(0, cellSize * (i + 1) - borderWidth, canvas.width, borderWidth);\n    });\n    new Array(patternWidth + 2).fill().forEach((_, i)=>{\n        context.fillRect(cellSize * i, 0, canvas.height, borderWidth);\n        context.fillRect(cellSize * (i + 1) - borderWidth, 0, borderWidth, canvas.height);\n    });\n};\nconst $25ddeeb3e8fa7df7$export$440d26a1852ff325 = (context, x, y, color)=>{\n    context.fillStyle = color;\n    // Displace cell by (+1, +1) to compensate for the 1-cell borders above.\n    const cellSize = $25ddeeb3e8fa7df7$var$cellSizes.cell;\n    const borderWidth = $25ddeeb3e8fa7df7$var$cellSizes.border;\n    const rect = [\n        (x + 1) * cellSize + borderWidth,\n        (y + 1) * cellSize + borderWidth,\n        cellSize - 2 * borderWidth,\n        cellSize - 2 * borderWidth\n    ];\n    context.fillRect(...rect);\n};\nconst $25ddeeb3e8fa7df7$export$a4f5dec905bc64b8 = (context, x, y)=>{\n    context.fillStyle = $25ddeeb3e8fa7df7$var$colorscheme.liveCell;\n    const { cell: cellSize , liveCell: liveCellSize  } = $25ddeeb3e8fa7df7$var$cellSizes;\n    const rect = [\n        // Draw at (x + 1, y + 1) for the same reason.\n        // Padding at each side is half the difference of cell sizes.\n        (x + 1) * cellSize + 0.5 * (cellSize - liveCellSize),\n        (y + 1) * cellSize + 0.5 * (cellSize - liveCellSize),\n        liveCellSize,\n        liveCellSize\n    ];\n    context.fillRect(...rect);\n};\nconst $25ddeeb3e8fa7df7$export$c90bea463c490a7a = (context, x, y)=>{\n    context.fillStyle = $25ddeeb3e8fa7df7$var$colorscheme.liveCell;\n    const { cell: cellSize , border: borderWidth , liveBorder: liveBorderWidth  } = $25ddeeb3e8fa7df7$var$cellSizes;\n    // Draw at (x + 1, y + 1) for the same reason.\n    const xLeft = (x + 1) * cellSize + borderWidth;\n    const xRight = (x + 2) * cellSize - borderWidth - liveBorderWidth;\n    const yTop = (y + 1) * cellSize + borderWidth;\n    const yBottom = (y + 2) * cellSize - borderWidth - liveBorderWidth;\n    const liveBorderLength = cellSize - 2 * borderWidth;\n    context.fillRect(xLeft, yTop, liveBorderLength, liveBorderWidth);\n    context.fillRect(xLeft, yBottom, liveBorderLength, liveBorderWidth);\n    context.fillRect(xLeft, yTop, liveBorderWidth, liveBorderLength);\n    context.fillRect(xRight, yTop, liveBorderWidth, liveBorderLength);\n};\n\n\n/**\n * @typedef {import('../../Models/AppState').default} AppState\n */ const $f8efe9e7a5a8ae37$var$drawLiveCellOptions = new Map([\n    [\n        \"none\",\n        ()=>{}\n    ],\n    [\n        \"border\",\n        $25ddeeb3e8fa7df7$export$c90bea463c490a7a\n    ],\n    [\n        \"interior\",\n        $25ddeeb3e8fa7df7$export$a4f5dec905bc64b8\n    ]\n]);\n/** @type {function(Array<{cell: Cell, subperiod: number}>): Array<number>} */ const $f8efe9e7a5a8ae37$var$getArrayFromSubperiods = (subperiods)=>{\n    const subperiodSet = new Set(subperiods.map((e)=>e.subperiod));\n    const subperiodArray = [\n        ...subperiodSet.values()\n    ].sort((a, b)=>a - b);\n    return subperiodArray;\n};\n/**\n * The view that takes care of the oscillizer canvas.\n * @class\n * @implements {IView}\n */ class $f8efe9e7a5a8ae37$var$OscillizerCanvasView {\n    /**\n   * @param {*} oscData\n   * @param {AppState} cellStyle\n   * @param {HTMLCanvasElement} targetCanvas\n   */ constructor(oscData, cellStyle, targetCanvas){\n        this.oscData = oscData;\n        this.cellStyle = cellStyle;\n        this.targetCanvas = targetCanvas;\n        /**\n     * The `update` callback that updates the view.\n     * @type {function(Event): void}\n     */ this.update = ()=>{\n            const context = this.targetCanvas.getContext(\"2d\");\n            if (!context) return;\n            // Dependent data\n            const { success: success , pattern: pattern , period: period , subperiods: subperiods , boundingBox: boundingBox  } = this.oscData.value;\n            const colorMap = $25ddeeb3e8fa7df7$export$dafb4586fe1f0b47(period, $f8efe9e7a5a8ae37$var$getArrayFromSubperiods(subperiods));\n            // Helper functions\n            const drawSubperiod = ({ cell: [x, y] , subperiod: subperiod  })=>{\n                $25ddeeb3e8fa7df7$export$440d26a1852ff325(context, x - boundingBox.xmin, y - boundingBox.ymin, colorMap.get(subperiod));\n            };\n            const drawLiveCell = ([x, y])=>{\n                const drawLiveCellOption = $f8efe9e7a5a8ae37$var$drawLiveCellOptions.get(this.cellStyle.value || \"none\");\n                drawLiveCellOption(context, x - boundingBox.xmin, y - boundingBox.ymin);\n            };\n            // Main Logic\n            context.clearRect(0, 0, targetCanvas.width, targetCanvas.height);\n            if (!success) return;\n            $25ddeeb3e8fa7df7$export$20d2db9c68afeac(targetCanvas, context, boundingBox);\n            subperiods.forEach(drawSubperiod);\n            pattern.forEach(drawLiveCell);\n        }; // end of `this.update`\n    }\n}\nvar $f8efe9e7a5a8ae37$export$2e2bcd8739ae039 = $f8efe9e7a5a8ae37$var$OscillizerCanvasView;\n\n\n/** @typedef {import('../../Models/AppState').default} AppState */ /**\n * @class\n * @implements {IView}\n */ class $df4da37397fd5fdc$var$OscStatsView {\n    /**\n   * @param {AppState} sourceState\n   * @param {HTMLElement} targetElement\n   */ constructor(sourceState, targetElement){\n        this.sourceState = sourceState;\n        this.targetElement = targetElement;\n        /** @type {function(Event): void} */ this.update = ()=>{\n            const data = this.sourceState.value;\n            if (!data.success) this.targetElement.innerText = `Failure: ${data.message}`;\n            else this.targetElement.innerHTML = `\n          <table>\n            <thead>\n              <tr>\n                <th>Property</th>\n                <th>Value</th>\n              </tr>\n            </thead>\n            <tbody>\n              <tr class=\"stripe-dark\">\n                <td>Period</td>\n                <td>${data.period}</td>\n              </tr>\n              <tr class=\"stripe-dark\">\n                <td>Population</td>\n                <td>Avg: ${data.avgPop}<br>Min: ${data.minPop}<br>Max: ${data.maxPop}</td>\n              </tr>\n              <tr class=\"stripe-dark\">\n                <td>Cells</td>\n                <td>\n                  Rotor: ${data.numRotorCells}<br>\n                  Stator: ${data.numStatorCells}<br>\n                  Total: ${data.numRotorCells + data.numStatorCells}\n                </td>\n              </tr>\n              <tr class=\"stripe-dark\">\n                <td>Volatility</td>\n                <td>${data.volatility}<br>(Strict: ${data.strictVolatility})</td>\n              </tr>\n              <tr class=\"stripe-dark\">\n                <td>Bounding Box</td>\n                <td>\n                  ${data.boundingBox.xmax - data.boundingBox.xmin + 1}\n                  x ${data.boundingBox.ymax - data.boundingBox.ymin + 1}\n                </td>\n              </tr>\n            </tbody>\n          </table>\n        `;\n             // if ... else\n        }; // this.update\n    }\n}\nvar $df4da37397fd5fdc$export$2e2bcd8739ae039 = $df4da37397fd5fdc$var$OscStatsView;\n\n\nconst $35da740d59af89ba$var$appState = {\n    oscInfo: new (0, $06c1141a5fa11022$export$2e2bcd8739ae039)(),\n    /*\n    Cell style for cells at gen 0\n    this.value: cellStyles.property\n  */ initialCellStyle: new (0, $06c1141a5fa11022$export$2e2bcd8739ae039)()\n};\n// @ts-ignore\nif (window.Cypress) // @ts-ignore\nwindow.appState = $35da740d59af89ba$var$appState;\n/* Action -> State update code */ const $35da740d59af89ba$var$inputRleSubmitter = document.getElementById(\"input-rle-submitter\");\nconst $35da740d59af89ba$var$cellStyleSelector = document.getElementById(\"cell-style-selector\");\nconst $35da740d59af89ba$var$inputRleContainer = document.getElementById(\"input-rle-container\");\nconst $35da740d59af89ba$var$oscController = new (0, $ce1ca3b02054b188$export$2e2bcd8739ae039)($35da740d59af89ba$var$appState.oscInfo, $35da740d59af89ba$var$inputRleContainer);\nconst $35da740d59af89ba$var$cellStyleController = new (0, $005cdf1a540a6299$export$2e2bcd8739ae039)($35da740d59af89ba$var$appState.initialCellStyle);\n$35da740d59af89ba$var$inputRleSubmitter.addEventListener(\"click\", $35da740d59af89ba$var$oscController.update);\n$35da740d59af89ba$var$cellStyleSelector.addEventListener(\"change\", $35da740d59af89ba$var$cellStyleController.update);\n/* State -> UI update code */ const $35da740d59af89ba$var$oscCanvas = /** @type {HTMLCanvasElement} */ document.getElementById(\"output-osc-canvas\");\nconst $35da740d59af89ba$var$oscCanvasView = new (0, $f8efe9e7a5a8ae37$export$2e2bcd8739ae039)($35da740d59af89ba$var$appState.oscInfo, $35da740d59af89ba$var$appState.initialCellStyle, $35da740d59af89ba$var$oscCanvas);\n$35da740d59af89ba$var$appState.oscInfo.eventTarget.addEventListener(\"change\", $35da740d59af89ba$var$oscCanvasView.update);\nconst $35da740d59af89ba$var$oscStatsElement = document.getElementById(\"output-osc-data\");\nconst $35da740d59af89ba$var$oscStatsView = new (0, $df4da37397fd5fdc$export$2e2bcd8739ae039)($35da740d59af89ba$var$appState.oscInfo, $35da740d59af89ba$var$oscStatsElement);\n$35da740d59af89ba$var$appState.oscInfo.eventTarget.addEventListener(\"change\", $35da740d59af89ba$var$oscStatsView.update);\n\n\n//# sourceMappingURL=index.80f92531.js.map\n","import AppState from \"./MVC/Models/AppState.js\";\nimport EventTargetPassingController from \"./MVC/Controllers/PassingController/EventTargetPassingController.js\";\nimport OscStatsController from \"./MVC/Controllers/OscStatsController/OscStatsController.js\";\nimport OscillizerCanvasView from \"./MVC/Views/OscillizerCanvasView/OscillizerCanvasView.js\";\nimport OscStatsView from \"./MVC/Views/OscStatsView/OscStatsView.js\";\n\nconst appState = {\n  oscInfo: new AppState(),\n\n  /*\n    Cell style for cells at gen 0\n    this.value: cellStyles.property\n  */\n  initialCellStyle: new AppState(),\n};\n\n// @ts-ignore\nif (window.Cypress) {\n  // @ts-ignore\n  window.appState = appState;\n}\n\n/* Action -> State update code */\n\nconst inputRleSubmitter = document.getElementById(\"input-rle-submitter\");\nconst cellStyleSelector = document.getElementById(\"cell-style-selector\");\nconst inputRleContainer = document.getElementById(\"input-rle-container\");\n\nconst oscController = new OscStatsController(\n  appState.oscInfo,\n  inputRleContainer\n);\nconst cellStyleController = new EventTargetPassingController(\n  appState.initialCellStyle\n);\n\ninputRleSubmitter.addEventListener(\"click\", oscController.update);\ncellStyleSelector.addEventListener(\"change\", cellStyleController.update);\n\n/* State -> UI update code */\n\nconst oscCanvas = /** @type {HTMLCanvasElement} */ (\n  document.getElementById(\"output-osc-canvas\")\n);\nconst oscCanvasView = new OscillizerCanvasView(\n  appState.oscInfo,\n  appState.initialCellStyle,\n  oscCanvas\n);\nappState.oscInfo.eventTarget.addEventListener(\"change\", oscCanvasView.update);\n\nconst oscStatsElement = document.getElementById(\"output-osc-data\");\nconst oscStatsView = new OscStatsView(appState.oscInfo, oscStatsElement);\nappState.oscInfo.eventTarget.addEventListener(\"change\", oscStatsView.update);\n","/**\n * A class that represents a single group of state.\n * @class\n */\nclass AppState {\n  /**\n   * @param {*} value - The initial value of this state\n   * @param {EventTarget} [eventTarget] - The EventTarget to use for firing state changes\n   */\n  constructor(value, eventTarget) {\n    /** @type {EventTarget} */\n    this.eventTarget = eventTarget || new EventTarget();\n    /** @type {*} */\n    this.value = value;\n  }\n\n  /**\n   * Set the value and fire `change` event.\n   * @param {*} newValue - The new value\n   */\n  setValue(newValue) {\n    this.value = newValue;\n    this.eventTarget.dispatchEvent(\n      new CustomEvent(\"change\", { detail: { source: this } })\n    );\n  }\n}\n\nexport default AppState;\n","/**\n * @typedef {import(\"./IController\").IController} IController\n * @typedef {import(\"../../Models/AppState\").default} AppState\n */\n\n/**\n * A controller that just passes the value of `event.target`.\n * `sourceElement` is not needed as we are using `event.target` anyway.\n * @class\n * @implements {IController}\n */\nclass EventTargetPassingController {\n  /**\n   * @param {AppState} targetState\n   */\n  constructor(targetState) {\n    /** @type {AppState} */\n    this.targetState = targetState;\n    /**\n     * The update callback.\n     * @type {function(Event): void}\n     */\n    this.update = (event) => {\n      if (!event.target) {\n        return;\n      }\n      // @ts-ignore\n      this.targetState.setValue(event.target.value);\n    };\n  }\n}\n\nexport default EventTargetPassingController;\n","import { parse as parseRLE } from \"./RLEHelpers.js\";\nimport { getOscStats } from \"./OscHelpers.js\";\nimport * as AppConfig from \"../../../AppConfig.js\";\n\n/**\n * @typedef {import('../PassingController/IController.js').IController}  IController\n * @typedef {import('../../Models/AppState').default} AppState\n */\n\n/**\n * A controller that updates the target with osc stats, with the given RLE.\n * @class\n * @implements {IController}\n */\nclass OscStatsController {\n  /**\n   * @param {AppState} targetState\n   * @param {HTMLInputElement} sourceElement\n   */\n  constructor(targetState, sourceElement) {\n    /** @type {AppState} */\n    this.targetState = targetState;\n    /** @type {HTMLInputElement} */\n    this.sourceElement = sourceElement;\n    /**\n     * The update callback.\n     * @type {function(Event): void}\n     */\n    this.update = (event) => {\n      if (!event.target) {\n        this.targetState.setValue({\n          success: false,\n          message: \"No event.target\",\n        });\n        return;\n      }\n      const rleString = this.sourceElement.value;\n      const { pattern, rule } = parseRLE(rleString);\n      if (!rule) {\n        this.targetState.setValue({\n          success: false,\n          message: \"Unable to parse rule\",\n        });\n        return;\n      }\n      const initialBoard = AppConfig.makeBoard(pattern, rule);\n      this.targetState.setValue(getOscStats(initialBoard));\n    };\n  }\n}\n\nexport default OscStatsController;\n","import PatternParser from \"../../../Engine/RLE/PatternParser.js\";\nimport {\n  parseINTRule,\n  parseTotalisticRule,\n} from \"../../../Engine/RLE/RuleParser.js\";\n\n/** @module */\n\nconst mapStateFromChar = new Map([\n  [\".\", 0],\n  [\"A\", 1],\n  [\"B\", 0],\n  [\"C\", 1],\n  [\"D\", 0],\n  [\"E\", 1],\n  [\"F\", 0],\n  [\"b\", 0],\n  [\"o\", 1],\n]);\n\n/**\n * @private\n * @param {PatternParser} parserState\n * @param {string} c\n * @returns {PatternParser}\n */\nconst updateParserState = (parserState, c) => {\n  // Passthrough if the parser is finished.\n  if (parserState.isFinished) {\n    return parserState;\n  }\n\n  if (c === \"!\") {\n    parserState.finishParsing();\n    return parserState;\n  }\n\n  // Update the run count if it is a digit\n  if (c >= \"0\" && c <= \"9\") {\n    const d = c.charCodeAt(0) - \"0\".charCodeAt(0);\n    parserState.updateRunCount(d);\n    return parserState;\n  }\n\n  // Jump to next line if it is '$'\n  if (c === \"$\") {\n    parserState.addNewlines();\n    return parserState;\n  }\n\n  // Draw the run if it is a character\n  const currState = mapStateFromChar.get(c) || 0;\n  parserState.drawRun(currState);\n  return parserState;\n};\n\n// Convert RLE without headers into a pattern of form [[x, y]]\nexport const parseBody = (rleBodyString) => {\n  const parseResult = [...rleBodyString].reduce(\n    updateParserState,\n    new PatternParser()\n  );\n  parseResult.finishParsing(); // No-op for now but semantically needed\n  return parseResult.cells;\n};\n\n/* Body extracting related code */\n\n/**\n * @private\n * @param {string} rleString\n * @returns {{body: string, rule: string|null}} The RLE Body and Rule, both as a string\n */\nconst extractParts = (rleString) => {\n  const lines = rleString\n    .split(\"\\n\")\n    .map((line) => line.replace(/\\s/g, \"\"))\n    .filter((line) => line !== \"\"); // We ignore empty lines\n\n  /** @type {function(string): boolean} */\n  const isNotComment = (line) => !line.startsWith(\"#\");\n  const firstNonCommentIndex = lines.findIndex(isNotComment);\n\n  const headerRegex = /^x=\\d+,y=\\d+,rule=(.*)/;\n  const matchedHeader = headerRegex.exec(lines[firstNonCommentIndex]);\n  const bodyStartIndex =\n    firstNonCommentIndex + (matchedHeader !== null ? 1 : 0);\n  const body = lines.slice(bodyStartIndex).join(\"\");\n  const rule = matchedHeader ? matchedHeader[1] : null;\n  return { body, rule };\n};\n\n/**\n * @typedef {import('../../../BaseTypes/Rule/Rule.js').Rule} Rule\n */\n\n/**\n * Given an RLE string, parse and return the rule and pattern.\n * @param {string} rleString - The RLE string.\n * @returns {{pattern: Array<Cell>, rule: Rule}} - The pattern and the rule.\n */\nexport const parse = (rleString) => {\n  const { rule: ruleString, body } = extractParts(rleString);\n  const pattern = parseBody(body);\n  const rule =\n    parseTotalisticRule(ruleString) || parseINTRule(ruleString) || undefined;\n  return { pattern, rule };\n};\n","/**\n * The intermediate state during RLE parsing.\n * @class\n */\nclass PatternParser {\n  /**\n   * Initialize the parser with the given state.\n   *\n   * @param {Object} initialState - The initial state to override with\n   * @property {boolean|undefined} initialState.isFinished\n   * @property {Array<Cell>|undefined} initialState.cells\n   * @property {Array<number>|undefined} initialState.runCount\n   * @property {Cell|undefined} initialState.currentCell\n   *\n   */\n  constructor(initialState = {}) {\n    /** @type {boolean} */\n    this.isFinished = initialState.isFinished || false;\n    /** @type {Array<Cell>} */\n    this.cells = initialState.cells || [];\n    /** @type {number} */\n    this.runCount = initialState.runCount || 0;\n    /** @type {Cell} */\n    this.currentCell = initialState.currentCell || [0, 0];\n  }\n\n  finishParsing() {\n    this.isFinished = true;\n  }\n\n  addNewlines() {\n    const [, /* x */ y] = this.currentCell;\n    const runCount = this.runCount || 1;\n    this.currentCell = [0, y + runCount];\n    this.runCount = 0;\n  }\n\n  /**\n   * Append `digit` to `this.runCount`\n   * @param {number} digit - The digit to append\n   */\n  updateRunCount(digit) {\n    this.runCount = this.runCount * 10 + digit;\n  }\n\n  /**\n   * @param {number} cellState\n   */\n  drawRun(cellState) {\n    const [x, y] = this.currentCell;\n    const runCount = this.runCount || 1;\n    const newCells = new Array(runCount).fill(0).map((v, i) => [x + i, y]);\n\n    // Refactor addNewCells into a dependency if needs variation in behavior\n    const addNewCells = (nc, s) => {\n      if (s) {\n        this.cells = this.cells.concat(nc);\n      }\n    };\n    addNewCells(newCells, cellState);\n\n    this.currentCell = [x + runCount, y];\n    this.runCount = 0;\n  }\n}\n\nexport default PatternParser;\n","import INTRule from \"../../BaseTypes/Rule/INTRule.js\";\nimport TotalisticRule from \"../../BaseTypes/Rule/TotalisticRule.js\";\n\n/**\n * Try to parse totalistic rule from rulestring.\n * @param {string} ruleString\n * @returns {TotalisticRule|undefined} - A totalistic rule on success, `undefined` on fail.\n */\nexport const parseTotalisticRule = (ruleString) => {\n  /**\n   * @private\n   * @typedef {{\n   *  success: boolean,\n   *  births: Array<number>,\n   *  survivals: Array<number>,\n   *  isBirth: boolean,\n   * }} State\n   */\n\n  /**\n   * @param {State} state\n   * @param {string} char\n   * @property {1} char.length\n   * @returns {State} The updated state\n   */\n  const updateState = (state, char) => {\n    if (!state.success) {\n      return state;\n    }\n\n    const { success, births, survivals, isBirth } = state;\n\n    switch (char) {\n      case \"0\":\n      case \"1\":\n      case \"2\":\n      case \"3\":\n      case \"4\":\n      case \"5\":\n      case \"6\":\n      case \"7\":\n      case \"8\":\n        (isBirth ? births : survivals).push(parseInt(char, 10));\n        return {\n          success,\n          births,\n          survivals,\n          isBirth,\n        };\n      case \"b\":\n      case \"B\":\n        return {\n          success,\n          births,\n          survivals,\n          isBirth: true,\n        };\n      case \"s\":\n      case \"S\":\n        return {\n          success,\n          births,\n          survivals,\n          isBirth: false,\n        };\n      case \"/\":\n        return {\n          success,\n          births,\n          survivals,\n          isBirth: !isBirth,\n        };\n      default:\n        return {\n          success: false,\n          births: [],\n          survivals: [],\n          isBirth: false,\n        };\n    }\n  };\n  const finalState = Array.from(ruleString).reduce(updateState, {\n    success: true,\n    births: [],\n    survivals: [],\n    isBirth: false,\n  });\n  if (!finalState.success) {\n    return undefined;\n  }\n  const births = [...new Set(finalState.births).keys()];\n  const survivals = [...new Set(finalState.survivals).keys()];\n  return new TotalisticRule(births, survivals);\n};\n\n/**\n * Try to parse an INT rule from rulestring.\n * @param {string} ruleString\n * @returns {INTRule|undefined} - An INT rule on success, `undefined` on fail.\n */\nexport const parseINTRule = (ruleString) => {\n  /**\n   * @typedef {import('../../BaseTypes/Neighbors/INTNeighbors.js').INTNeighbor} INTNeighbor\n   */\n\n  /**\n   * @private\n   * @typedef {{\n   *  isBirth: boolean,\n   *  births: Set<INTNeighbor>,\n   *  survivals: Set<INTNeighbor>,\n   * }} State\n   */\n\n  // Dependent function and objects\n\n  /** @type {function(State): State} */\n  const copyWithBirth = (state) => ({\n    isBirth: true,\n    births: state.births,\n    survivals: state.survivals,\n  });\n\n  /** @type {function(State): State} */\n  const copyWithSurvival = (state) => ({\n    isBirth: false,\n    births: state.births,\n    survivals: state.survivals,\n  });\n\n  /** @type {function(State): State} */\n  const copyWithToggledBirth = (state) => ({\n    isBirth: !state.isBirth,\n    births: state.births,\n    survivals: state.survivals,\n  });\n\n  // Assumes word matches `/[0-8][-cekainyqjrtwz]/`\n  /** @type {Array<Array<INTNeighbor>>} */\n  const allNeighborsByCount = [\n    [\"0\"],\n    [\"1c\", \"1e\"],\n    [\"2c\", \"2e\", \"2a\", \"2k\", \"2i\", \"2n\"],\n    [\"3c\", \"3e\", \"3a\", \"3k\", \"3i\", \"3n\", \"3j\", \"3q\", \"3r\", \"3y\"],\n    [\n      \"4c\",\n      \"4e\",\n      \"4a\",\n      \"4k\",\n      \"4i\",\n      \"4n\",\n      \"4j\",\n      \"4q\",\n      \"4r\",\n      \"4y\",\n      \"4t\",\n      \"4w\",\n      \"4z\",\n    ],\n    [\"5c\", \"5e\", \"5a\", \"5k\", \"5i\", \"5n\", \"5j\", \"5q\", \"5r\", \"5y\"],\n    [\"6c\", \"6e\", \"6a\", \"6k\", \"6i\", \"6n\"],\n    [\"7c\", \"7e\"],\n    [\"8\"],\n  ];\n\n  /** @type {Array<(Map<string, INTNeighbor>)>} */\n  const neighborsByCountAndChar = [\n    new Map(),\n    new Map([\n      [\"c\", \"1c\"],\n      [\"e\", \"1e\"],\n    ]),\n    new Map([\n      [\"c\", \"2c\"],\n      [\"e\", \"2e\"],\n      [\"a\", \"2a\"],\n      [\"k\", \"2k\"],\n      [\"i\", \"2i\"],\n      [\"n\", \"2n\"],\n    ]),\n    new Map([\n      [\"c\", \"3c\"],\n      [\"e\", \"3e\"],\n      [\"a\", \"3a\"],\n      [\"k\", \"3k\"],\n      [\"i\", \"3i\"],\n      [\"n\", \"3n\"],\n      [\"j\", \"3j\"],\n      [\"q\", \"3q\"],\n      [\"r\", \"3r\"],\n      [\"y\", \"3y\"],\n    ]),\n    new Map([\n      [\"c\", \"4c\"],\n      [\"e\", \"4e\"],\n      [\"a\", \"4a\"],\n      [\"k\", \"4k\"],\n      [\"i\", \"4i\"],\n      [\"n\", \"4n\"],\n      [\"j\", \"4j\"],\n      [\"q\", \"4q\"],\n      [\"r\", \"4r\"],\n      [\"y\", \"4y\"],\n      [\"w\", \"4w\"],\n      [\"t\", \"4t\"],\n      [\"z\", \"4z\"],\n    ]),\n    new Map([\n      [\"c\", \"5c\"],\n      [\"e\", \"5e\"],\n      [\"a\", \"5a\"],\n      [\"k\", \"5k\"],\n      [\"i\", \"5i\"],\n      [\"n\", \"5n\"],\n      [\"j\", \"5j\"],\n      [\"q\", \"5q\"],\n      [\"r\", \"5r\"],\n      [\"y\", \"5y\"],\n    ]),\n    new Map([\n      [\"c\", \"6c\"],\n      [\"e\", \"6e\"],\n      [\"a\", \"6a\"],\n      [\"k\", \"6k\"],\n      [\"i\", \"6i\"],\n      [\"n\", \"6n\"],\n    ]),\n    new Map([\n      [\"c\", \"7c\"],\n      [\"e\", \"7e\"],\n    ]),\n    new Map(),\n  ];\n\n  /** @type {function(string): Set<INTNeighbor>} */\n  const getNeighborsFromWord = (word) => {\n    const neighborSet = new Set();\n    const count = parseInt(word[0], 10);\n    // The chars before the first `-` are births\n    // The chars after them are survivals\n    const [birthsString, ...survivalsStrings] = word.slice(1).split(\"-\");\n    if (birthsString === \"\") {\n      allNeighborsByCount[count].forEach((n) => neighborSet.add(n));\n    } else {\n      Array.from(birthsString).forEach((c) =>\n        neighborSet.add(neighborsByCountAndChar[count].get(c))\n      );\n    }\n    Array.from(survivalsStrings.join(\"\")).forEach((c) =>\n      neighborSet.delete(neighborsByCountAndChar[count].get(c))\n    );\n    return neighborSet;\n  };\n\n  // Main logic\n  /** @type {State} */\n  const initialState = {\n    isBirth: false,\n    births: new Set(),\n    survivals: new Set(),\n  };\n\n  const words = ruleString.match(/[bBsS/]|[0-8][-cekainyqjrtwz]*/g);\n  if (words.reduce((psum, w) => psum + w.length, 0) !== ruleString.length) {\n    return undefined;\n  }\n  const finalState = words.reduce((state, word) => {\n    if (word === \"b\" || word === \"B\") {\n      return copyWithBirth(state);\n    }\n    if (word === \"s\" || word === \"S\") {\n      return copyWithSurvival(state);\n    }\n    if (word === \"/\") {\n      return copyWithToggledBirth(state);\n    }\n    // Neighbors\n    const neighborsSet = getNeighborsFromWord(word);\n    const targetSet = state.isBirth ? state.births : state.survivals;\n    neighborsSet.forEach((n) => targetSet.add(n));\n    return state;\n  }, initialState);\n  return new INTRule([...finalState.births], [...finalState.survivals]);\n};\n","/**\n * @typedef {import('../Neighbors/INTNeighbors').INTNeighbor} INTNeighbor\n */\n\n/**\n * An Isotropic non-totalistic rule with the given birth and survival conditions.\n */\nclass INTRule {\n  /**\n   * @param {Array<INTNeighbor>} births - The birth conditions\n   * @param {Array<INTNeighbor>} survivals - The survival conditions\n   */\n  constructor(births, survivals) {\n    /** @type {Array<INTNeighbor>} */ this.births = births;\n    /** @type {Array<INTNeighbor>} */ this.survivals = survivals;\n  }\n}\nexport default INTRule;\n","/**\n * A Totalistic Rule subclass with the given birth and survival conditions.\n */\nclass TotalisticRule {\n  /**\n   * @param {Array<number>} births\n   * @param {Array<number>} survivals\n   */\n  constructor(births, survivals) {\n    /** @type {Array<number>} */ this.births = births;\n    /** @type {Array<number>} */ this.survivals = survivals;\n  }\n}\nexport default TotalisticRule;\n","import BoundingBox from \"../../../BaseTypes/BoundingBox.js\";\nimport CellMap from \"../../../BaseTypes/CellMap.js\";\n\n/**\n * Helper functions for oscillator-related functionality\n * @module\n */\n\n/**\n * @typedef {import('../../../Engine/Board/IBoard.js').IBoard} IBoard\n */\n\n/**\n * Given an oscillator, return the board of each phase of the oscillation. (t=0..p-1)\n * Given a non-oscillator, return `[]`.\n * @param {IBoard} board - The initial board.\n * @param {number} maxGens - Maximum number of gens to detect oscillation.\n * @returns {Array<IBoard>} - All phases of the oscillator, or an empty array.\n */\nexport const getPhases = (board, maxGens = 1000) => {\n  /**\n   * @param {Array} array\n   * @param {Set} set\n   * @returns {boolean}\n   */\n  const haveSameMembers = (array, set) =>\n    array.length === set.size && array.every((cell) => set.has(cell));\n\n  const appendNextBoard = ({ result, lastBoards, initialCellsSet }) => {\n    if (result.length !== 0) {\n      return { result, lastBoards, initialCellsSet };\n    }\n    /** @type {IBoard} */\n    const lastBoard = lastBoards[lastBoards.length - 1];\n    /** @type {IBoard} */\n    const currBoard = lastBoard.after();\n    if (haveSameMembers(currBoard.getCells(), initialCellsSet)) {\n      return {\n        result: lastBoards,\n        lastBoards: [],\n        initialCellsSet,\n      };\n    }\n    return {\n      result: [],\n      lastBoards: lastBoards.concat(currBoard),\n      initialCellsSet,\n    };\n  };\n\n  const repeatForMaxGens = new Array(maxGens).fill();\n  const initialData = {\n    result: [],\n    lastBoards: [board],\n    initialCellsSet: CellMap.fromKeys(board.getCells()),\n  };\n  const phases = repeatForMaxGens.reduce(appendNextBoard, initialData).result;\n  return phases; // Return empty array on failure\n};\n\n/**\n * Given the phases of an oscillator, calculate and return the subperiod of each cell.\n * @param {Array<IBoard>} oscPhaseBoards - The phases of an oscillator\n * @returns {Array<{cell: Cell, subperiod: number}>} - Subperiods for every cell.\n */\nexport const getSubperiodByCell = (oscPhaseBoards) => {\n  // Get the list of oscillator phases.\n  // Return a list of `{ cell, aliveGens }` where `aliveGens` is the gens `cell` was alive.\n  const getAliveGensByCell = (phases) => {\n    const phasesSet = phases.map(CellMap.fromKeys);\n    const allCells = CellMap.fromKeys([].concat(...phases)).keys();\n    const gens = phases.map((_, gen) => gen);\n    return allCells.map((cell) => ({\n      cell,\n      aliveGens: gens.filter((gen) => phasesSet[gen].has(cell)),\n    }));\n  };\n\n  // Get the list of gens a cell was alive.\n  // Return the subperiod.\n  const getSubperiodOfOneCell = (aliveGens, period) => {\n    const aliveGensSet = new Set(aliveGens);\n    const subperiods = new Array(period)\n      .fill()\n      .map((_, i) => i + 1)\n      .filter((n) => period % n === 0);\n    const isSubperiodValid = (n) =>\n      aliveGens.map((g) => (g + n) % period).every((g) => aliveGensSet.has(g));\n    const validSubperiods = subperiods.filter(isSubperiodValid);\n    return Math.min(...validSubperiods);\n  };\n\n  const period = oscPhaseBoards.length;\n  const result = getAliveGensByCell(\n    oscPhaseBoards.map((b) => b.getCells())\n  ).map(({ cell, aliveGens }) => ({\n    cell,\n    subperiod: getSubperiodOfOneCell(aliveGens, period),\n  }));\n  return result;\n};\n\n/**\n * Given a board of the oscillator, return the stats of the oscillator.\n * @param {IBoard} board - Initial oscillator\n * @returns {*} stats - The oscillator statistics\n */\nexport const getOscStats = (board) => {\n  // Basic functions\n  /** @type {function(Array<number>): number} */\n  const getAverage = (l) => l.reduce((a, b) => a + b, 0) / l.length;\n\n  /** @type {function(number): string} */\n  const formatFloat = (f) => f.toFixed(2);\n\n  /** @type {function(number): string} */\n  const formatPercentage = (f) => `${(100 * f).toFixed(2)}%`;\n\n  // Status functions\n  /** @typedef {Array<{cell: Cell, subperiod: number}>} Subperiods */\n\n  /** @type {function(Subperiods): number} */\n  const getRotorCount = (subperiods) =>\n    subperiods.filter(({ subperiod }) => subperiod !== 1).length;\n\n  /** @type {function(Subperiods, number): number} */\n  const getStrictRotorCount = (subperiods, period) =>\n    subperiods.filter(({ subperiod }) => subperiod === period).length;\n\n  /** @type {function(Subperiods): number} */\n  const getVolatility = (subperiods) =>\n    getRotorCount(subperiods) / subperiods.length;\n\n  /** @type {function(Subperiods, number): number} */\n  const getStrictVolatility = (subperiods, period) =>\n    getStrictRotorCount(subperiods, period) / subperiods.length;\n\n  // Main code\n  const phaseBoards = getPhases(board);\n  const period = phaseBoards.length;\n  if (period === 0) {\n    return {\n      success: false,\n      message: \"Failed to detect period of pattern\",\n    };\n  }\n  const populations = phaseBoards.map((b) => b.getPop());\n  const subperiods = getSubperiodByCell(phaseBoards);\n\n  const result = {\n    success: true,\n    pattern: board.getCells(),\n    period,\n    phases: phaseBoards.map((p) => p.getCells()),\n    subperiods,\n    minPop: Math.min(...populations),\n    maxPop: Math.max(...populations),\n    avgPop: formatFloat(getAverage(populations)),\n    numCells: subperiods.length,\n    numRotorCells: getRotorCount(subperiods),\n    numStatorCells: subperiods.length - getRotorCount(subperiods),\n    numStrictRotorCells: getStrictRotorCount(subperiods, period),\n    volatility: formatPercentage(getVolatility(subperiods)),\n    strictVolatility: formatPercentage(getStrictVolatility(subperiods, period)),\n    boundingBox: BoundingBox.sum(phaseBoards.map((p) => p.getBox())),\n  };\n  return result;\n};\n","/**\n * A bounding box consists of min/max of the X/Y coordinates.\n * For an empty pattern the bounding box is `(Inf, Inf, -Inf, -Inf)`\n * because it's an identity in the addition below.\n */\nclass BoundingBox {\n  /**\n   * @param {number} xmin\n   * @param {number} xmax\n   * @param {number} ymin\n   * @param {number} ymax\n   */\n  constructor(\n    xmin = Infinity,\n    xmax = -Infinity,\n    ymin = Infinity,\n    ymax = -Infinity\n  ) {\n    /** @type {number} */ this.xmin = xmin;\n    /** @type {number} */ this.xmax = xmax;\n    /** @type {number} */ this.ymin = ymin;\n    /** @type {number} */ this.ymax = ymax;\n  }\n\n  /**\n   * Return a new bounding box that is the result of\n   * merging `this` with the `other` bounding box.\n   *\n   * @param {BoundingBox} other - The other box to merge with.\n   * @returns {BoundingBox} - The merged bounding box.\n   */\n  plus(other) {\n    const xmin = Math.min(this.xmin, other.xmin);\n    const xmax = Math.max(this.xmax, other.xmax);\n    const ymin = Math.min(this.ymin, other.ymin);\n    const ymax = Math.max(this.ymax, other.ymax);\n    return new BoundingBox(xmin, xmax, ymin, ymax);\n  }\n\n  /**\n   * Given an array of bounding boxes, merge all of them and return the merged box.\n   *\n   * @param  {Array<BoundingBox>} boxes - The boxes to merge.\n   * @returns {BoundingBox} - The merged bounding box.\n   */\n  static sum(boxes) {\n    return boxes.reduce((psum, box) => psum.plus(box), new BoundingBox());\n  }\n}\n\nexport default BoundingBox;\n","/**\n * @private\n * @type {function(number, number): string}\n */\nconst cellToString = (x, y) => `${x} ${y}`;\n\n/**\n * @private\n * @type {function(string): Cell}\n */\nconst stringToCell = (s) => s.split(\" \").map((e) => parseInt(e, 10));\n\n/**\n * Map data structure that accepts Cells: [x: number, y: number] as keys.\n *\n * We need to implement this because\n * JS does not support non-primitive value types as keys (as of ES6)\n */\nclass CellMap {\n  /**\n   * @param {Array<CellEntry>} [entries=[]]\n   */\n  constructor(entries = []) {\n    /** @type {Map<string, *>} */ this.map = new Map();\n    entries.forEach(([x, y], value) => this.set([x, y], value));\n  }\n\n  /**\n   * Generate and return a `CellMap` from list of keys.\n   *\n   * @param {Array} keys - Array of cells, each of type `[number, number]`.\n   * @returns - The CellMap having the given keys with values mapped to null\n   */\n  static fromKeys(keys) {\n    const map = new CellMap();\n    keys.forEach(([x, y]) => map.set([x, y], null));\n    return map;\n  }\n\n  /**\n   * Generate and return a `CellMap` with the given entries.\n   *\n   * This is the same as the constructor, but is presented here\n   * as an analogue to `fromKeys`.\n   *\n   * @param {Array} entries - Array of [cell, value] pairs\n   * @returns The resulting CellMap having the given entries\n   */\n  static fromEntries(entries) {\n    return new CellMap(entries);\n  }\n\n  /**\n   * Return whether a cell is in the map to Map.\n   *\n   * @param {*} key - cell to search for, has type `[number, number]`.\n   * @returns A boolean indicating whether the cell is in the set\n   */\n  has(key) {\n    const [x, y] = key;\n    return this.map.has(cellToString(x, y));\n  }\n\n  /**\n   * Get the value for the given key.\n   * If not found, return `defaultValue` as a fallback.\n   *\n   * @param {Cell} key - The key to get values for.\n   * @param {*} defaultValue - The value to return when the key is not found.\n   * @returns - The found value or `defaultValue`\n   */\n  get(key, defaultValue) {\n    const [x, y] = key;\n    const value = this.map.get(cellToString(x, y));\n    return value !== undefined ? value : defaultValue;\n  }\n\n  /**\n   * Set the value for the given key.\n   *\n   * @param {Cell} key - The key to set values for.\n   * @param {*} value - The value to set.\n   */\n  set(key, value) {\n    const [x, y] = key;\n    this.map.set(cellToString(x, y), value);\n  }\n\n  /**\n   * Return the number of keys of the map, analogous to `Map`.\n   */\n  get size() {\n    return this.map.size;\n  }\n\n  /**\n   * Return the keys of this map as in `Map`.\n   * @returns A list of keys for the map.\n   */\n  keys() {\n    return [...this.map.keys()].map(stringToCell);\n  }\n\n  /**\n   * Return the entries (i.e. key, value pairs) of this map, as in `Map`.\n   * @returns A list of entries for the map.\n   */\n  entries() {\n    return [...this.map.entries()].map(([s, v]) => [stringToCell(s), v]);\n  }\n}\n\nexport default CellMap;\n","import SimpleTotalisticBoard from \"./Engine/Board/SimpleBoard/SimpleTotalisticBoard.js\";\nimport TotalisticRule from \"./BaseTypes/Rule/TotalisticRule.js\";\nimport INTRule from \"./BaseTypes/Rule/INTRule.js\";\nimport SimpleINTBoard from \"./Engine/Board/SimpleBoard/SimpleINTBoard.js\";\n\nconst life = new TotalisticRule([3], [2, 3]);\n\n/**\n * @typedef {import('./Engine/Board/IBoard.js').IBoard} IBoard\n * @typedef {import('./BaseTypes/Rule/Rule.js').Rule} Rule\n */\n\n/**\n * Create and return a new two-state board with the given pattern and rule.\n * @todo `rule` should be changed later to support different rulestings.\n *\n * @function makeBoard\n * @param {TwoStatePattern} pattern - The initial pattern.\n * @param {Rule} [rule=life] - The rule to use, this should be compatible with the board used.\n * @returns {IBoard} - The board\n */\nexport const makeBoard = (pattern, rule = life) => {\n  if (rule.constructor === TotalisticRule) {\n    return new SimpleTotalisticBoard(pattern, rule);\n  }\n  if (rule.constructor === INTRule) {\n    return new SimpleINTBoard(pattern, rule);\n  }\n  throw new Error(\"Invalid Rule!\");\n};\n\n/**\n * Create and return a new empty board with the given rule.\n * @todo `rule` should be changed later to support different rulestings.\n *\n * @function makeBoard\n * @param {Rule} [rule] - The rule to use, this should be compatible with the board used.\n * @returns {IBoard} - The board\n */\nexport const makeEmptyBoard = (rule = life) => makeBoard([], rule);\n","import AbcSimpleBoard from \"./AbcSimpleBoard.js\";\nimport CellMap from \"../../../BaseTypes/CellMap.js\";\n\nconst moore = [\n  [-1, -1],\n  [-1, 0],\n  [-1, 1],\n  [0, -1],\n  [0, 0],\n  [0, 1],\n  [1, -1],\n  [1, 0],\n  [1, 1],\n];\n\n/**\n * @private\n * @param {Array<Cell>} cellsArray\n * @param {Array<Cell>} neighbors\n * @returns {CellMap}\n */\nconst getNeighborCounts = (cellsArray, neighbors) => {\n  const neighborCountsMap = new CellMap();\n  cellsArray.forEach(([x, y]) => {\n    neighbors.forEach(([dx, dy]) => {\n      const targetCell = [x + dx, y + dy];\n      const count = neighborCountsMap.get(targetCell) || 0;\n      neighborCountsMap.set(targetCell, count + 1);\n    });\n  });\n  return neighborCountsMap;\n};\n\n/**\n * @typedef {import('./AbcSimpleBoard').TransitionFunction} TransitionFunction\n */\n\n/**\n * @private\n * @param {TotalisticRule} totalisticRule\n * @returns {TransitionFunction}\n */\nconst makeTransFromTotalisticRule = (totalisticRule) => (cellsArray) => {\n  const { births, survivals } = totalisticRule;\n  const neighborCounts = getNeighborCounts(cellsArray, moore);\n  const cellsSet = CellMap.fromKeys(cellsArray);\n  const ruleCondition = ([cell, count]) =>\n    cellsSet.has(cell)\n      ? survivals.includes(count - 1) // -1: `count` includes `cell`, while B/S notation doesn't\n      : births.includes(count);\n  return [...neighborCounts.entries()]\n    .filter(ruleCondition)\n    .map(([cell /* count */]) => cell);\n};\n\n/**\n * A sample implementation for totalistic rules.\n * @class\n * @implements {ITotalisticBoard}\n */\nclass SimpleTotalisticBoard extends AbcSimpleBoard {\n  /**\n   * Initialize the board with the given pattern and rule.\n   *\n   * @constructor\n   * @param {TwoStatePattern} pattern - The initial pattern.\n   * @param {TotalisticRule} rule - The rule to operate on the pattern with.\n   * @param {number} [gen=0] - The initial generation.\n   */\n  constructor(pattern, rule, gen = 0) {\n    super(pattern, rule, gen);\n    this.transitionFunction = makeTransFromTotalisticRule(rule);\n  }\n}\n\nexport default SimpleTotalisticBoard;\n","import BoundingBox from \"../../../BaseTypes/BoundingBox.js\";\n\n/**\n * @typedef {import('../../../BaseTypes/Rule/Rule').Rule} Rule\n * @typedef {import('../IBoard').IBoard} IBoard\n * @typedef {import('./SimpleTotalisticBoard').default} SimpleTotalisticBoard\n */\n\n/**\n * @typedef {function(Array<Cell>): Array<Cell>} TransitionFunction\n */\n\n/**\n * This simple interface consists of a `pattern` and a `transitionFunction`.\n * It applies the `transitionFunction` on the `pattern` to get the next generation.\n * Other auxillary information is extracted from the `pattern`.\n *\n * IMPORTANT:\n *\n *  This class is made to reduce boilerplate.\n *  You don't need to inherit from this class;\n *  You just have to implement `I{Totalistic,INT}Board` interfaces.\n *\n *  If you are using this class, make sure to initialize `this.transitionFunction` properly,\n *  with the rule given as the parameter, with the proper type of {@link TransitionFunction}.\n *  For example classes, see {@link SimpleTotalisticBoard}.\n *\n * @implements {IBoard}\n *\n */\nclass AbcSimpleBoard {\n  /**\n   * @param {TwoStatePattern} pattern\n   * @param {Rule} rule\n   * @param {number} gen\n   */\n  constructor(pattern, rule, gen) {\n    /** @type {TwoStatePattern} */\n    this.pattern = pattern;\n    /** @type {Rule} */\n    this.rule = rule;\n    /** @type {number} */\n    this.gen = gen;\n    /**\n     * This should be overriden by concrete implementations!\n     * @type {any}\n     */\n    this.transitionFunction = undefined;\n  }\n\n  getCells() {\n    return this.pattern;\n  }\n\n  getCellsAndStates() {\n    return this.pattern.map((cell) => [cell, 1]);\n  }\n\n  getBox() {\n    return BoundingBox.sum(\n      this.pattern.map(([x, y]) => new BoundingBox(x, x, y, y))\n    );\n  }\n\n  getPop() {\n    return this.pattern.length;\n  }\n\n  /**\n   * Return a new board with the pattern iterated by the given amount.\n   *\n   * @param {number} [gens=1] - Number of generations to iterate\n   * @returns {AbcSimpleBoard} - The new board\n   */\n  after(gens = 1) {\n    const repeatForGens = new Array(gens).fill();\n    /** @type {TransitionFunction} */\n    const transFunc = this.transitionFunction;\n    /** @type {Array<Cell>} */\n    const iteratedPattern = repeatForGens.reduce(transFunc, this.pattern);\n    /** @type {any} */\n    const ThisClass = this.constructor;\n    return new ThisClass(iteratedPattern, this.rule, this.gen + gens);\n  }\n}\n\nexport default AbcSimpleBoard;\n","import AbcSimpleBoard from \"./AbcSimpleBoard.js\";\nimport CellMap from \"../../../BaseTypes/CellMap.js\";\nimport { intNeighborsByIndex } from \"../../../BaseTypes/Neighbors/INTNeighbors.js\";\n\n/**\n * @typedef {import('./AbcSimpleBoard').TransitionFunction} TransitionFunction\n */\n\nconst weightsByRelPos = new Map([\n  [[-1, -1], 1],\n  [[-1, 0], 2],\n  [[-1, 1], 4],\n  [[0, -1], 8],\n  [[0, 0], 16],\n  [[0, 1], 32],\n  [[1, -1], 64],\n  [[1, 0], 128],\n  [[1, 1], 256],\n]);\n\n/**\n * @private\n * @param {Array<Cell>} cellsArray\n * @returns {CellMap}\n */\nconst getNeighborTransitionIndexes = (cellsArray) => {\n  const neighborTransitions = new CellMap();\n  cellsArray.forEach(([x, y]) => {\n    weightsByRelPos.forEach((w, [dx, dy]) => {\n      const targetCell = [x - dx, y - dy]; // So that [x, y] is at rel. pos. [dx, dy]\n      const currentWeight = neighborTransitions.get(targetCell) || 0;\n      neighborTransitions.set(targetCell, currentWeight + w);\n    });\n  });\n  return neighborTransitions;\n};\n\n/**\n * @private\n * @param {INTRule} rule\n * @returns {TransitionFunction}\n */\nconst makeTransitionFunction = (rule) => (cellsArray) => {\n  const transitionIndexesByCell = getNeighborTransitionIndexes(cellsArray);\n  const nextCells = [...transitionIndexesByCell.entries()]\n    .filter(([, tIndex]) => {\n      // The 0x10 bit is the center cell.\n      // eslint-disable-next-line no-bitwise\n      const cellIsAlive = (tIndex & 0x10) !== 0;\n      const validTransitions = cellIsAlive ? rule.survivals : rule.births;\n      return validTransitions.includes(intNeighborsByIndex[tIndex]);\n    })\n    .map(([cell] /* [cell, tIndex] */) => cell);\n  return nextCells;\n};\n\nclass SimpleINTBoard extends AbcSimpleBoard {\n  /**\n   * @param {TwoStatePattern} pattern\n   * @param {INTRule} rule\n   * @param {number} gen\n   */\n  constructor(pattern, rule, gen = 0) {\n    super(pattern, rule, gen);\n    /** @type {TransitionFunction} */\n    this.transitionFunction = makeTransitionFunction(rule);\n  }\n}\n\nexport default SimpleINTBoard;\n","/** @module */\n\n/**\n * An enum for specifying neighbors for INT rules.\n */\nexport const INT = {\n  // eslint-disable-next-line quote-props\n  0: \"0\",\n\n  \"1c\": \"1c\",\n  \"1e\": \"1e\",\n\n  \"2c\": \"2c\",\n  \"2e\": \"2e\",\n  \"2a\": \"2a\",\n  \"2k\": \"2k\",\n  \"2i\": \"2i\",\n  \"2n\": \"2n\",\n\n  \"3c\": \"3c\",\n  \"3e\": \"3e\",\n  \"3a\": \"3a\",\n  \"3k\": \"3k\",\n  \"3i\": \"3i\",\n  \"3n\": \"3n\",\n  \"3j\": \"3j\",\n  \"3q\": \"3q\",\n  \"3r\": \"3r\",\n  \"3y\": \"3y\",\n\n  \"4c\": \"4c\",\n  \"4e\": \"4e\",\n  \"4a\": \"4a\",\n  \"4k\": \"4k\",\n  \"4i\": \"4i\",\n  \"4n\": \"4n\",\n  \"4j\": \"4j\",\n  \"4q\": \"4q\",\n  \"4r\": \"4r\",\n  \"4y\": \"4y\",\n  \"4t\": \"4t\",\n  \"4w\": \"4w\",\n  \"4z\": \"4z\",\n\n  \"5c\": \"5c\",\n  \"5e\": \"5e\",\n  \"5a\": \"5a\",\n  \"5k\": \"5k\",\n  \"5i\": \"5i\",\n  \"5n\": \"5n\",\n  \"5j\": \"5j\",\n  \"5q\": \"5q\",\n  \"5r\": \"5r\",\n  \"5y\": \"5y\",\n\n  \"6c\": \"6c\",\n  \"6e\": \"6e\",\n  \"6a\": \"6a\",\n  \"6k\": \"6k\",\n  \"6i\": \"6i\",\n  \"6n\": \"6n\",\n\n  \"7c\": \"7c\",\n  \"7e\": \"7e\",\n\n  // eslint-disable-next-line quote-props\n  8: \"8\",\n};\n\n/**\n * @typedef {keyof(INT)} INTNeighbor\n */\n\n// Initialize the index to neighbor table.\n/** @type {Array<INTNeighbor>} */\nexport const intNeighborsByIndex = `\n    0 1c 1e 2a 1c 2c 2a 3i 1e 2a 2e 3a 2k 3n 3j 4a\n    0 1c 1e 2a 1c 2c 2a 3i 1e 2a 2e 3a 2k 3n 3j 4a\n    1e 2k 2e 3j 2a 3n 3a 4a 2i 3r 3e 4r 3r 4i 4r 5i\n    1e 2k 2e 3j 2a 3n 3a 4a 2i 3r 3e 4r 3r 4i 4r 5i\n    1c 2c 2k 3n 2n 3c 3q 4n 2a 3i 3j 4a 3q 4n 4w 5a\n    1c 2c 2k 3n 2n 3c 3q 4n 2a 3i 3j 4a 3q 4n 4w 5a\n    2k 3y 3k 4k 3q 4y 4q 5j 3r 4t 4j 5n 4z 5r 5q 6a\n    2k 3y 3k 4k 3q 4y 4q 5j 3r 4t 4j 5n 4z 5r 5q 6a\n    1e 2k 2i 3r 2k 3y 3r 4t 2e 3j 3e 4r 3k 4k 4j 5n\n    1e 2k 2i 3r 2k 3y 3r 4t 2e 3j 3e 4r 3k 4k 4j 5n\n    2e 3k 3e 4j 3j 4k 4r 5n 3e 4j 4e 5c 4j 5y 5c 6c\n    2e 3k 3e 4j 3j 4k 4r 5n 3e 4j 4e 5c 4j 5y 5c 6c\n    2a 3n 3r 4i 3q 4y 4z 5r 3a 4a 4r 5i 4q 5j 5q 6a\n    2a 3n 3r 4i 3q 4y 4z 5r 3a 4a 4r 5i 4q 5j 5q 6a\n    3j 4k 4j 5y 4w 5k 5q 6k 4r 5n 5c 6c 5q 6k 6n 7c\n    3j 4k 4j 5y 4w 5k 5q 6k 4r 5n 5c 6c 5q 6k 6n 7c\n    1c 2n 2k 3q 2c 3c 3n 4n 2k 3q 3k 4q 3y 4y 4k 5j\n    1c 2n 2k 3q 2c 3c 3n 4n 2k 3q 3k 4q 3y 4y 4k 5j\n    2a 3q 3j 4w 3i 4n 4a 5a 3r 4z 4j 5q 4t 5r 5n 6a\n    2a 3q 3j 4w 3i 4n 4a 5a 3r 4z 4j 5q 4t 5r 5n 6a\n    2c 3c 3y 4y 3c 4c 4y 5e 3n 4n 4k 5j 4y 5e 5k 6e\n    2c 3c 3y 4y 3c 4c 4y 5e 3n 4n 4k 5j 4y 5e 5k 6e\n    3n 4y 4k 5k 4n 5e 5j 6e 4i 5r 5y 6k 5r 6i 6k 7e\n    3n 4y 4k 5k 4n 5e 5j 6e 4i 5r 5y 6k 5r 6i 6k 7e\n    2a 3q 3r 4z 3n 4y 4i 5r 3j 4w 4j 5q 4k 5k 5y 6k\n    2a 3q 3r 4z 3n 4y 4i 5r 3j 4w 4j 5q 4k 5k 5y 6k\n    3a 4q 4r 5q 4a 5j 5i 6a 4r 5q 5c 6n 5n 6k 6c 7c\n    3a 4q 4r 5q 4a 5j 5i 6a 4r 5q 5c 6n 5n 6k 6c 7c\n    3i 4n 4t 5r 4n 5e 5r 6i 4a 5a 5n 6a 5j 6e 6k 7e\n    3i 4n 4t 5r 4n 5e 5r 6i 4a 5a 5n 6a 5j 6e 6k 7e\n    4a 5j 5n 6k 5a 6e 6a 7e 5i 6a 6c 7c 6a 7e 7c 8\n    4a 5j 5n 6k 5a 6e 6a 7e 5i 6a 6c 7c 6a 7e 7c 8\n  `\n  .trim()\n  .split(/\\s+/);\n","import * as CanvasHelpers from \"./CanvasHelpers.js\";\n\n/**\n * @typedef {import('../../Models/AppState').default} AppState\n */\n\nconst drawLiveCellOptions = new Map([\n  [\"none\", () => {}],\n  [\"border\", CanvasHelpers.drawLiveCellBorder],\n  [\"interior\", CanvasHelpers.drawLiveCellInterior],\n]);\n\n/** @type {function(Array<{cell: Cell, subperiod: number}>): Array<number>} */\nconst getArrayFromSubperiods = (subperiods) => {\n  const subperiodSet = new Set(subperiods.map((e) => e.subperiod));\n  const subperiodArray = [...subperiodSet.values()].sort((a, b) => a - b);\n  return subperiodArray;\n};\n\n/**\n * The view that takes care of the oscillizer canvas.\n * @class\n * @implements {IView}\n */\nclass OscillizerCanvasView {\n  /**\n   * @param {*} oscData\n   * @param {AppState} cellStyle\n   * @param {HTMLCanvasElement} targetCanvas\n   */\n  constructor(oscData, cellStyle, targetCanvas) {\n    this.oscData = oscData;\n    this.cellStyle = cellStyle;\n    this.targetCanvas = targetCanvas;\n    /**\n     * The `update` callback that updates the view.\n     * @type {function(Event): void}\n     */\n    this.update = (/* event */) => {\n      const context = this.targetCanvas.getContext(\"2d\");\n      if (!context) {\n        return;\n      }\n\n      // Dependent data\n      const { success, pattern, period, subperiods, boundingBox } =\n        this.oscData.value;\n      const colorMap = CanvasHelpers.makeColorMap(\n        period,\n        getArrayFromSubperiods(subperiods)\n      );\n\n      // Helper functions\n      const drawSubperiod = ({ cell: [x, y], subperiod }) => {\n        CanvasHelpers.drawCell(\n          context,\n          x - boundingBox.xmin,\n          y - boundingBox.ymin,\n          colorMap.get(subperiod)\n        );\n      };\n\n      const drawLiveCell = ([x, y]) => {\n        const drawLiveCellOption = drawLiveCellOptions.get(\n          this.cellStyle.value || \"none\"\n        );\n        drawLiveCellOption(context, x - boundingBox.xmin, y - boundingBox.ymin);\n      };\n\n      // Main Logic\n      context.clearRect(0, 0, targetCanvas.width, targetCanvas.height);\n      if (!success) {\n        return;\n      }\n      CanvasHelpers.drawGrid(targetCanvas, context, boundingBox);\n      subperiods.forEach(drawSubperiod);\n      pattern.forEach(drawLiveCell);\n    }; // end of `this.update`\n  }\n}\n\nexport default OscillizerCanvasView;\n","/**\n * @typedef {import('../../../BaseTypes/BoundingBox').default} BoundingBox\n */\n\nconst colorscheme = {\n  background: \"#eeeeee\",\n  stator: \"#000000\",\n  strictRotor: \"#999999\",\n  liveCell: \"#000000\",\n};\n\n// Cell size follows `box-sizing: border-box`\n// In other words, borders on all four sides are counted as cellSize.\nconst cellSizes = {\n  cell: 10,\n  border: 1,\n  liveCell: 4,\n  liveBorder: 2,\n};\n\n/** @type {function(number, number): string} */\nconst makeGradientColor = (numColors, i) => {\n  const hue = Math.floor(360 * (i / numColors));\n  return `hsl(${hue}, 100%, 70%)`;\n};\n\n/** @type {function(number, Array<number>): Map<number, string>} */\nexport const makeColorMap = (period, subperiods) => {\n  // Remove special subperiods:\n  //  subperiod 1 (stator)\n  //  subperiod `period` (full-period rotor)\n  const subperiodsSet = new Set(subperiods);\n  subperiodsSet.delete(1);\n  subperiodsSet.delete(period);\n  const nonSpecialSubperiods = [...subperiodsSet.values()].sort(\n    (a, b) => a - b\n  );\n  /** @type {Array<[number, string]>} */\n  const nonSpecialSubperiodsAndColors = nonSpecialSubperiods.map((sp, i) => [\n    sp,\n    makeGradientColor(nonSpecialSubperiods.length, i),\n  ]);\n  return new Map([\n    ...nonSpecialSubperiodsAndColors,\n    [1, colorscheme.stator],\n    [period, colorscheme.strictRotor],\n  ]);\n};\n\n// Draw the initial grid\n/**\n * @param {HTMLCanvasElement} canvas\n * @param {*} context\n * @param {BoundingBox} boundingBox\n */\nexport const drawGrid = (canvas, context, boundingBox) => {\n  // We have to manipulate the canvas, so first beg pardon to ESLint\n  /* eslint-disable no-param-reassign */\n\n  const { cell: cellSize, border: borderWidth } = cellSizes;\n\n  // First fill rect with empty cell backgrounds.\n  const patternWidth = boundingBox.xmax - boundingBox.xmin + 1;\n  const patternHeight = boundingBox.ymax - boundingBox.ymin + 1;\n\n  // Add one cell for padding on each side.\n  canvas.width = cellSize * (patternWidth + 2);\n  canvas.height = cellSize * (patternHeight + 2);\n\n  // Draw background\n  context.fillStyle = colorscheme.background;\n  context.fillRect(0, 0, canvas.width, canvas.height);\n\n  // Draw cell borders\n  context.fillStyle = \"white\";\n  new Array(patternHeight + 2).fill().forEach((_, i) => {\n    context.fillRect(0, cellSize * i, canvas.width, borderWidth);\n    context.fillRect(\n      0,\n      cellSize * (i + 1) - borderWidth,\n      canvas.width,\n      borderWidth\n    );\n  });\n  new Array(patternWidth + 2).fill().forEach((_, i) => {\n    context.fillRect(cellSize * i, 0, canvas.height, borderWidth);\n    context.fillRect(\n      cellSize * (i + 1) - borderWidth,\n      0,\n      borderWidth,\n      canvas.height\n    );\n  });\n};\n\n/**\n * Draw the cell at `(x, y)` with the given color.\n * @param {*} context\n * @param {number} x\n * @param {number} y\n * @param {string} color\n */\nexport const drawCell = (context, x, y, color) => {\n  context.fillStyle = color;\n  // Displace cell by (+1, +1) to compensate for the 1-cell borders above.\n  const cellSize = cellSizes.cell;\n  const borderWidth = cellSizes.border;\n  const rect = [\n    (x + 1) * cellSize + borderWidth,\n    (y + 1) * cellSize + borderWidth,\n    cellSize - 2 * borderWidth,\n    cellSize - 2 * borderWidth,\n  ];\n  context.fillRect(...rect);\n};\n\n/**\n * Draw the interior of the cell at (x, y), with styling as live cell.\n * @param {*} context\n * @param {number} x\n * @param {number} y\n */\nexport const drawLiveCellInterior = (context, x, y) => {\n  context.fillStyle = colorscheme.liveCell;\n  const { cell: cellSize, liveCell: liveCellSize } = cellSizes;\n  const rect = [\n    // Draw at (x + 1, y + 1) for the same reason.\n    // Padding at each side is half the difference of cell sizes.\n    (x + 1) * cellSize + 0.5 * (cellSize - liveCellSize),\n    (y + 1) * cellSize + 0.5 * (cellSize - liveCellSize),\n    liveCellSize,\n    liveCellSize,\n  ];\n  context.fillRect(...rect);\n};\n\n/**\n * Draw the border of the cell at (x, y), with styling as a live cell.\n * @param {*} context\n * @param {number} x\n * @param {number} y\n */\nexport const drawLiveCellBorder = (context, x, y) => {\n  context.fillStyle = colorscheme.liveCell;\n  const {\n    cell: cellSize,\n    border: borderWidth,\n    liveBorder: liveBorderWidth,\n  } = cellSizes;\n  // Draw at (x + 1, y + 1) for the same reason.\n  const xLeft = (x + 1) * cellSize + borderWidth;\n  const xRight = (x + 2) * cellSize - borderWidth - liveBorderWidth;\n  const yTop = (y + 1) * cellSize + borderWidth;\n  const yBottom = (y + 2) * cellSize - borderWidth - liveBorderWidth;\n  const liveBorderLength = cellSize - 2 * borderWidth;\n  context.fillRect(xLeft, yTop, liveBorderLength, liveBorderWidth);\n  context.fillRect(xLeft, yBottom, liveBorderLength, liveBorderWidth);\n  context.fillRect(xLeft, yTop, liveBorderWidth, liveBorderLength);\n  context.fillRect(xRight, yTop, liveBorderWidth, liveBorderLength);\n};\n","/** @typedef {import('../../Models/AppState').default} AppState */\n\n/**\n * @class\n * @implements {IView}\n */\nclass OscStatsView {\n  /**\n   * @param {AppState} sourceState\n   * @param {HTMLElement} targetElement\n   */\n  constructor(sourceState, targetElement) {\n    this.sourceState = sourceState;\n    this.targetElement = targetElement;\n    /** @type {function(Event): void} */\n    this.update = (/* event */) => {\n      const data = this.sourceState.value;\n      if (!data.success) {\n        this.targetElement.innerText = `Failure: ${data.message}`;\n      } else {\n        this.targetElement.innerHTML = `\n          <table>\n            <thead>\n              <tr>\n                <th>Property</th>\n                <th>Value</th>\n              </tr>\n            </thead>\n            <tbody>\n              <tr class=\"stripe-dark\">\n                <td>Period</td>\n                <td>${data.period}</td>\n              </tr>\n              <tr class=\"stripe-dark\">\n                <td>Population</td>\n                <td>Avg: ${data.avgPop}<br>Min: ${data.minPop}<br>Max: ${\n          data.maxPop\n        }</td>\n              </tr>\n              <tr class=\"stripe-dark\">\n                <td>Cells</td>\n                <td>\n                  Rotor: ${data.numRotorCells}<br>\n                  Stator: ${data.numStatorCells}<br>\n                  Total: ${data.numRotorCells + data.numStatorCells}\n                </td>\n              </tr>\n              <tr class=\"stripe-dark\">\n                <td>Volatility</td>\n                <td>${data.volatility}<br>(Strict: ${\n          data.strictVolatility\n        })</td>\n              </tr>\n              <tr class=\"stripe-dark\">\n                <td>Bounding Box</td>\n                <td>\n                  ${data.boundingBox.xmax - data.boundingBox.xmin + 1}\n                  x ${data.boundingBox.ymax - data.boundingBox.ymin + 1}\n                </td>\n              </tr>\n            </tbody>\n          </table>\n        `;\n      } // if ... else\n    }; // this.update\n  }\n}\n\nexport default OscStatsView;\n"],"names":["$06c1141a5fa11022$export$2e2bcd8739ae039","constructor","value","eventTarget","EventTarget","setValue","newValue","dispatchEvent","CustomEvent","detail","source","$7eb306c3bbaced74$export$2e2bcd8739ae039","initialState","isFinished","cells","runCount","currentCell","finishParsing","addNewlines","y","updateRunCount","digit","drawRun","cellState","x","newCells","Array","fill","map","v","i","addNewCells","nc","s","concat","$5fea755afec9d72f$export$2e2bcd8739ae039","births","survivals","$6c574ea9d853ec19$export$2e2bcd8739ae039","$7e08f398c2dbe9e4$export$9e91b46a83237852","ruleString","finalState","from","reduce","state","char","success","isBirth","push","parseInt","Set","keys","$7e08f398c2dbe9e4$export$6f3ef6963fbc63d1","copyWithBirth","copyWithSurvival","copyWithToggledBirth","allNeighborsByCount","neighborsByCountAndChar","Map","getNeighborsFromWord","word","neighborSet","count","birthsString","survivalsStrings","slice","split","forEach","n","add","c","get","join","delete","words","match","psum","w","length","neighborsSet","targetSet","$c0a50bf5651c6c70$var$mapStateFromChar","$c0a50bf5651c6c70$var$updateParserState","parserState","d","charCodeAt","currState","$c0a50bf5651c6c70$export$3b629cd0ff482602","rleBodyString","parseResult","$c0a50bf5651c6c70$var$extractParts","rleString","lines","line","replace","filter","firstNonCommentIndex","findIndex","startsWith","matchedHeader","headerRegex","exec","body","rule","$c0a50bf5651c6c70$export$98e6a39c04603d36","pattern","undefined","$4fe0a788fb08d993$var$BoundingBox","xmin","Infinity","xmax","ymin","ymax","plus","other","Math","min","max","sum","boxes","box","$b455d5ebeb71c1de$var$cellToString","$b455d5ebeb71c1de$var$stringToCell","e","$b455d5ebeb71c1de$var$CellMap","entries","set","fromKeys","fromEntries","has","key","defaultValue","size","$33c87e009b185634$export$decf60f46c2b52d8","board","maxGens","haveSameMembers","array","every","cell","repeatForMaxGens","initialData","result","lastBoards","initialCellsSet","getCells","phases","lastBoard","currBoard","after","$33c87e009b185634$export$2f3e39639c1a2e58","oscPhaseBoards","getSubperiodOfOneCell","aliveGens","period","aliveGensSet","subperiods","_","validSubperiods","g","getAliveGensByCell","phasesSet","allCells","gens","gen","b","subperiod","$33c87e009b185634$export$a50fceef87b2948","formatPercentage","f","toFixed","getRotorCount","getStrictRotorCount","phaseBoards","message","populations","getPop","p","minPop","maxPop","avgPop","l","a","numCells","numRotorCells","numStatorCells","numStrictRotorCells","volatility","strictVolatility","boundingBox","getBox","$7c60ee827e62c391$export$2e2bcd8739ae039","transitionFunction","getCellsAndStates","repeatForGens","transFunc","iteratedPattern","ThisClass","$cdbcd7a52f96e34a$var$moore","$cdbcd7a52f96e34a$var$getNeighborCounts","cellsArray","neighbors","neighborCountsMap","dx","dy","targetCell","$cdbcd7a52f96e34a$var$makeTransFromTotalisticRule","totalisticRule","neighborCounts","cellsSet","includes","$cdbcd7a52f96e34a$export$2e2bcd8739ae039","$a97e00b3534022fc$export$10cb2c208909f427","trim","$e7bed22a29553bb6$var$weightsByRelPos","$e7bed22a29553bb6$var$getNeighborTransitionIndexes","neighborTransitions","currentWeight","$e7bed22a29553bb6$var$makeTransitionFunction","transitionIndexesByCell","nextCells","tIndex","validTransitions","cellIsAlive","$e7bed22a29553bb6$export$2e2bcd8739ae039","$3f27e148c19edda2$var$life","$3f27e148c19edda2$export$c68329e72259b1d3","Error","$ce1ca3b02054b188$export$2e2bcd8739ae039","targetState","sourceElement","update","event","target","initialBoard","$25ddeeb3e8fa7df7$var$colorscheme","background","stator","strictRotor","liveCell","$25ddeeb3e8fa7df7$var$cellSizes","border","liveBorder","$25ddeeb3e8fa7df7$var$makeGradientColor","numColors","floor","$25ddeeb3e8fa7df7$export$dafb4586fe1f0b47","subperiodsSet","nonSpecialSubperiods","values","sort","nonSpecialSubperiodsAndColors","sp","$25ddeeb3e8fa7df7$export$20d2db9c68afeac","canvas","context","cellSize","borderWidth","patternWidth","patternHeight","width","height","fillStyle","fillRect","$25ddeeb3e8fa7df7$export$440d26a1852ff325","color","$f8efe9e7a5a8ae37$var$drawLiveCellOptions","liveBorderWidth","xLeft","xRight","yTop","yBottom","liveBorderLength","liveCellSize","rect","$f8efe9e7a5a8ae37$var$getArrayFromSubperiods","subperiodSet","subperiodArray","$f8efe9e7a5a8ae37$export$2e2bcd8739ae039","oscData","cellStyle","targetCanvas","getContext","colorMap","clearRect","drawLiveCellOption","$35da740d59af89ba$var$appState","oscInfo","initialCellStyle","window","Cypress","appState","$35da740d59af89ba$var$inputRleSubmitter","document","getElementById","$35da740d59af89ba$var$cellStyleSelector","$35da740d59af89ba$var$inputRleContainer","$35da740d59af89ba$var$oscController","$35da740d59af89ba$var$cellStyleController","addEventListener","$35da740d59af89ba$var$oscCanvas","$35da740d59af89ba$var$oscCanvasView","$35da740d59af89ba$var$oscStatsElement","$35da740d59af89ba$var$oscStatsView","sourceState","targetElement","data","innerHTML","innerText"],"version":3,"file":"index.80f92531.js.map"}